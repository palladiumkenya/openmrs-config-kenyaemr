{"mappings":"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","sources":["packages/@react-aria/dnd/src/useDroppableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  clearGlobalDnDState,\n  DIRECTORY_DRAG_TYPE,\n  droppableCollectionMap,\n  getTypes,\n  globalDndState,\n  isInternalDropOperation,\n  setDropCollectionRef\n} from './utils';\nimport {\n  Collection,\n  DropEvent,\n  DropOperation,\n  DroppableCollectionDropEvent,\n  DroppableCollectionProps,\n  DropPosition,\n  DropTarget,\n  DropTargetDelegate,\n  Key,\n  KeyboardDelegate,\n  Node,\n  RefObject\n} from '@react-types/shared';\nimport * as DragManager from './DragManager';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {HTMLAttributes, useCallback, useEffect, useRef} from 'react';\nimport {mergeProps, useId, useLayoutEffect} from '@react-aria/utils';\nimport {setInteractionModality} from '@react-aria/interactions';\nimport {useAutoScroll} from './useAutoScroll';\nimport {useDrop} from './useDrop';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface DroppableCollectionOptions extends DroppableCollectionProps {\n  /** A delegate object that implements behavior for keyboard focus movement. */\n  keyboardDelegate: KeyboardDelegate,\n  /** A delegate object that provides drop targets for pointer coordinates within the collection. */\n  dropTargetDelegate: DropTargetDelegate\n}\n\nexport interface DroppableCollectionResult {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\ninterface DroppingState {\n  collection: Collection<Node<unknown>>,\n  focusedKey: Key,\n  selectedKeys: Set<Key>,\n  target: DropTarget,\n  draggingKeys: Set<Key>,\n  isInternal: boolean,\n  timeout: ReturnType<typeof setTimeout>\n}\n\nconst DROP_POSITIONS: DropPosition[] = ['before', 'on', 'after'];\nconst DROP_POSITIONS_RTL: DropPosition[] = ['after', 'on', 'before'];\n\n/**\n * Handles drop interactions for a collection component, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDroppableCollection(props: DroppableCollectionOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement | null>): DroppableCollectionResult {\n  let localState = useRef({\n    props,\n    state,\n    nextTarget: null,\n    dropOperation: null\n  }).current;\n  localState.props = props;\n  localState.state = state;\n\n  let defaultOnDrop = useCallback(async (e: DroppableCollectionDropEvent) => {\n    let {\n      onInsert,\n      onRootDrop,\n      onItemDrop,\n      onReorder,\n      acceptedDragTypes = 'all',\n      shouldAcceptItemDrop\n    } = localState.props;\n\n    let {draggingKeys} = globalDndState;\n    let isInternal = isInternalDropOperation(ref);\n    let {\n      target,\n      dropOperation,\n      items\n    } = e;\n\n    let filteredItems = items;\n    if (acceptedDragTypes !== 'all' || shouldAcceptItemDrop) {\n      filteredItems = items.filter(item => {\n        let itemTypes: Set<string | symbol>;\n        if (item.kind === 'directory') {\n          itemTypes = new Set([DIRECTORY_DRAG_TYPE]);\n        } else {\n          itemTypes = item.kind === 'file' ? new Set([item.type]) : item.types;\n        }\n\n        if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => itemTypes.has(type))) {\n          // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions\n          // than the droppable collection itself\n          if (target.type === 'item' && target.dropPosition === 'on' && shouldAcceptItemDrop) {\n            return shouldAcceptItemDrop(target, itemTypes);\n          }\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    if (filteredItems.length > 0) {\n      if (target.type === 'root' && onRootDrop) {\n        await onRootDrop({items: filteredItems, dropOperation});\n      }\n\n      if (target.type === 'item') {\n        if (target.dropPosition === 'on' && onItemDrop) {\n          await onItemDrop({items: filteredItems, dropOperation, isInternal, target});\n        }\n\n        if (target.dropPosition !== 'on') {\n          if (!isInternal && onInsert) {\n            await onInsert({items: filteredItems, dropOperation, target});\n          }\n\n          if (isInternal && onReorder) {\n            await onReorder({keys: draggingKeys, dropOperation, target});\n          }\n        }\n      }\n    }\n  }, [localState, ref]);\n\n  let autoScroll = useAutoScroll(ref);\n  let {dropProps} = useDrop({\n    ref,\n    onDropEnter() {\n      state.setTarget(localState.nextTarget);\n    },\n    onDropMove(e) {\n      state.setTarget(localState.nextTarget);\n      autoScroll.move(e.x, e.y);\n    },\n    getDropOperationForPoint(types, allowedOperations, x, y) {\n      let {draggingKeys, dropCollectionRef} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      let isValidDropTarget = (target) => state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys}) !== 'cancel';\n      let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);\n      if (!target) {\n        localState.dropOperation = 'cancel';\n        localState.nextTarget = null;\n        return 'cancel';\n      }\n\n      localState.dropOperation = state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys});\n\n      // If the target doesn't accept the drop, see if the root accepts it instead.\n      if (localState.dropOperation === 'cancel') {\n        let rootTarget: DropTarget = {type: 'root'};\n        let dropOperation = state.getDropOperation({target: rootTarget, types, allowedOperations, isInternal, draggingKeys});\n        if (dropOperation !== 'cancel') {\n          target = rootTarget;\n          localState.dropOperation = dropOperation;\n        }\n      }\n\n      // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit\n      // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).\n      if (target && localState.dropOperation !== 'cancel' && ref?.current !== dropCollectionRef?.current) {\n        setDropCollectionRef(ref);\n      }\n      localState.nextTarget = localState.dropOperation === 'cancel' ? null : target;\n      return localState.dropOperation;\n    },\n    onDropExit() {\n      setDropCollectionRef(undefined);\n      state.setTarget(null);\n      autoScroll.stop();\n    },\n    onDropActivate(e) {\n      if (state.target?.type === 'item' && state.target?.dropPosition === 'on' && typeof props.onDropActivate === 'function') {\n        props.onDropActivate({\n          type: 'dropactivate',\n          x: e.x, // todo\n          y: e.y,\n          target: state.target\n        });\n      }\n    },\n    onDrop(e) {\n      setDropCollectionRef(ref);\n      if (state.target) {\n        onDrop(e, state.target);\n      }\n\n      // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n      // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd\n      let {draggingCollectionRef} = globalDndState;\n      if (draggingCollectionRef == null) {\n        clearGlobalDnDState();\n      }\n    }\n  });\n\n  let droppingState = useRef<DroppingState>(null);\n  let updateFocusAfterDrop = useCallback(() => {\n    let {state} = localState;\n    if (droppingState.current) {\n      let {\n        target,\n        collection: prevCollection,\n        selectedKeys: prevSelectedKeys,\n        focusedKey: prevFocusedKey,\n        isInternal,\n        draggingKeys\n      } = droppingState.current;\n      \n      // If an insert occurs during a drop, we want to immediately select these items to give\n      // feedback to the user that a drop occurred. Only do this if the selection didn't change\n      // since the drop started so we don't override if the user or application did something.\n      if (\n        state.collection.size > prevCollection.size &&\n        state.selectionManager.isSelectionEqual(prevSelectedKeys)\n      ) {\n        let newKeys = new Set<Key>();\n        for (let key of state.collection.getKeys()) {\n          if (!prevCollection.getItem(key)) {\n            newKeys.add(key);\n          }\n        }\n\n        state.selectionManager.setSelectedKeys(newKeys);\n\n        // If the focused item didn't change since the drop occurred, also focus the first\n        // inserted item. If selection is disabled, then also show the focus ring so there\n        // is some indication that items were added.\n        if (state.selectionManager.focusedKey === prevFocusedKey) {\n          let first = newKeys.keys().next().value;\n          let item = state.collection.getItem(first);\n\n          // If this is a cell, focus the parent row.\n          if (item?.type === 'cell') {\n            first = item.parentKey;\n          }\n\n          state.selectionManager.setFocusedKey(first);\n\n          if (state.selectionManager.selectionMode === 'none') {\n            setInteractionModality('keyboard');\n          }\n        }\n      } else if (\n        state.selectionManager.focusedKey === prevFocusedKey &&\n        isInternal &&\n        target.type === 'item' &&\n        target.dropPosition !== 'on' &&\n        draggingKeys.has(state.collection.getItem(prevFocusedKey)?.parentKey)\n      ) {\n        // Focus row instead of cell when reordering.\n        state.selectionManager.setFocusedKey(state.collection.getItem(prevFocusedKey).parentKey);\n        setInteractionModality('keyboard');\n      } else if (\n        state.selectionManager.focusedKey === prevFocusedKey &&\n        target.type === 'item' && \n        target.dropPosition === 'on' && \n        state.collection.getItem(target.key) != null\n      ) {\n        // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,\n        // focus that item and show the focus ring to give the user feedback that the drop occurred.\n        // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.\n        state.selectionManager.setFocusedKey(target.key);\n        setInteractionModality('keyboard');\n      } else if (!state.selectionManager.isSelected(state.selectionManager.focusedKey)) {\n        setInteractionModality('keyboard');\n      }\n\n      state.selectionManager.setFocused(true);\n    }\n  }, [localState]);\n\n  let onDrop = useCallback((e: DropEvent, target: DropTarget) => {\n    let {state} = localState;\n    \n    // Save some state of the collection/selection before the drop occurs so we can compare later.\n    droppingState.current = {\n      timeout: null,\n      focusedKey: state.selectionManager.focusedKey,\n      collection: state.collection,\n      selectedKeys: state.selectionManager.selectedKeys,\n      draggingKeys: globalDndState.draggingKeys,\n      isInternal: isInternalDropOperation(ref),\n      target\n    };\n\n    let onDropFn = localState.props.onDrop || defaultOnDrop;\n    onDropFn({\n      type: 'drop',\n      x: e.x, // todo\n      y: e.y,\n      target,\n      items: e.items,\n      dropOperation: e.dropOperation\n    });\n\n    // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously\n    // and for React to re-render. If the collection didn't already change during this time (handled below),\n    // update the focused key here.\n    droppingState.current.timeout = setTimeout(() => {\n      updateFocusAfterDrop();\n      droppingState.current = null;\n    }, 50);\n  }, [localState, defaultOnDrop, ref, updateFocusAfterDrop]);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      if (droppingState.current) {\n        clearTimeout(droppingState.current.timeout);\n      }\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    // If the collection changed after a drop, update the focused key.\n    if (droppingState.current && state.collection !== droppingState.current.collection) {\n      updateFocusAfterDrop();\n    }\n  });\n\n  let {direction} = useLocale();\n  useEffect(() => {\n    let getNextTarget = (target: DropTarget, wrap = true, horizontal = false): DropTarget => {\n      if (!target) {\n        return {\n          type: 'root'\n        };\n      }\n\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = dropPositions[0];\n\n      if (target.type === 'item') {\n        // If the the keyboard delegate returned the next key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let nextCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);\n        if (nextKey == null || nextKey === nextCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex + 1];\n          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'after', then 'before' on the next key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[2]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let getPreviousTarget = (target: DropTarget, wrap = true, horizontal = false): DropTarget => {\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = !target || target.type === 'root' ? dropPositions[2] : 'on';\n\n      if (target?.type === 'item') {\n        // If the the keyboard delegate returned the previous key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let prevCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);\n        if (nextKey == null || nextKey === prevCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex - 1];\n          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'before', then 'after' on the previous key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[0]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let nextValidTarget = (\n      target: DropTarget,\n      types: Set<string>,\n      allowedDropOperations: DropOperation[],\n      getNextTarget: (target: DropTarget, wrap: boolean) => DropTarget,\n      wrap = true\n    ): DropTarget => {\n      let seenRoot = 0;\n      let operation: DropOperation;\n      let {draggingKeys} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      do {\n        let nextTarget = getNextTarget(target, wrap);\n        if (!nextTarget) {\n          return null;\n        }\n        target = nextTarget;\n        operation = localState.state.getDropOperation({target: nextTarget, types, allowedOperations: allowedDropOperations, isInternal, draggingKeys});\n        if (target.type === 'root') {\n          seenRoot++;\n        }\n      } while (\n        operation === 'cancel' &&\n        !localState.state.isDropTarget(target) &&\n        seenRoot < 2\n      );\n\n      if (operation === 'cancel') {\n        return null;\n      }\n\n      return target;\n    };\n\n    return DragManager.registerDropTarget({\n      element: ref.current,\n      preventFocusOnDrop: true,\n      getDropOperation(types, allowedOperations) {\n        if (localState.state.target) {\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          return localState.state.getDropOperation({target: localState.state.target, types, allowedOperations, isInternal, draggingKeys});\n        }\n\n        // Check if any of the targets accept the drop.\n        // TODO: should we have a faster way of doing this or e.g. for pagination?\n        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);\n        return target ? 'move' : 'cancel';\n      },\n      onDropEnter(e, drag) {\n        let types = getTypes(drag.items);\n        let selectionManager = localState.state.selectionManager;\n        let target: DropTarget;\n        // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check\n        setDropCollectionRef(ref);\n\n        // When entering the droppable collection for the first time, the default drop target\n        // is after the focused key.\n        let key = selectionManager.focusedKey;\n        let dropPosition: DropPosition = 'after';\n\n        // If the focused key is a cell, get the parent item instead.\n        // For now, we assume that individual cells cannot be dropped on.\n        let item = localState.state.collection.getItem(key);\n        if (item?.type === 'cell') {\n          key = item.parentKey;\n        }\n\n        // If the focused item is also selected, the default drop target is after the last selected item.\n        // But if the focused key is the first selected item, then default to before the first selected item.\n        // This is to make reordering lists slightly easier. If you select top down, we assume you want to\n        // move the items down. If you select bottom up, we assume you want to move the items up.\n        if (selectionManager.isSelected(key)) {\n          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) {\n            dropPosition = 'before';\n          } else {\n            key = selectionManager.lastSelectedKey;\n          }\n        }\n\n        if (key != null) {\n          target = {\n            type: 'item',\n            key,\n            dropPosition\n          };\n\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          // If the default target is not valid, find the next one that is.\n          if (localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys}) === 'cancel') {\n            target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n              ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n          }\n        }\n\n        // If no focused key, then start from the root.\n        if (!target) {\n          target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n        }\n\n        localState.state.setTarget(target);\n      },\n      onDropExit() {\n        setDropCollectionRef(undefined);\n        localState.state.setTarget(null);\n      },\n      onDropTargetEnter(target) {\n        localState.state.setTarget(target);\n      },\n      onDropActivate(e) {\n        if (\n          localState.state.target?.type === 'item' &&\n          localState.state.target?.dropPosition === 'on' &&\n          typeof localState.props.onDropActivate === 'function'\n        ) {\n          localState.props.onDropActivate({\n            type: 'dropactivate',\n            x: e.x, // todo\n            y: e.y,\n            target: localState.state.target\n          });\n        }\n      },\n      onDrop(e, target) {\n        setDropCollectionRef(ref);\n        if (localState.state.target) {\n          onDrop(e, target || localState.state.target);\n        }\n      },\n      onKeyDown(e, drag) {\n        let {keyboardDelegate} = localState.props;\n        let types = getTypes(drag.items);\n        switch (e.key) {\n          case 'ArrowDown': {\n            if (keyboardDelegate.getKeyBelow) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowUp': {\n            if (keyboardDelegate.getKeyAbove) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowLeft': {\n            if (keyboardDelegate.getKeyLeftOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getPreviousTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            if (keyboardDelegate.getKeyRightOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getNextTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'Home': {\n            if (keyboardDelegate.getFirstKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'End': {\n            if (keyboardDelegate.getLastKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'PageDown': {\n            if (keyboardDelegate.getKeyPageBelow) {\n              let target = localState.state.target;\n              if (!target) {\n                target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              } else {\n                // If on the root, go to the item a page below the top. Otherwise a page below the current item.\n                let nextKey = keyboardDelegate.getKeyPageBelow(\n                  target.type === 'item'\n                    ? target.key\n                    : keyboardDelegate.getFirstKey()\n                );\n                let dropPosition = target.type === 'item' ? target.dropPosition : 'after';\n\n                // If there is no next key, or we are starting on the last key, jump to the last possible position.\n                if (nextKey == null || (target.type === 'item' && target.key === keyboardDelegate.getLastKey())) {\n                  nextKey = keyboardDelegate.getLastKey();\n                  dropPosition = 'after';\n                }\n\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n\n                // If the target does not accept the drop, find the next valid target.\n                // If no next valid target, find the previous valid target.\n                let {draggingCollectionRef, draggingKeys} = globalDndState;\n                let isInternal = draggingCollectionRef?.current === ref?.current;\n                let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n                if (operation === 'cancel') {\n                  target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n                    ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n                }\n              }\n\n              localState.state.setTarget(target ?? localState.state.target);\n            }\n            break;\n          }\n          case 'PageUp': {\n            if (!keyboardDelegate.getKeyPageAbove) {\n              break;\n            }\n\n            let target = localState.state.target;\n            if (!target) {\n              target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n            } else if (target.type === 'item') {\n              // If at the top already, switch to the root. Otherwise navigate a page up.\n              if (target.key === keyboardDelegate.getFirstKey()) {\n                target = {\n                  type: 'root'\n                };\n              } else {\n                let nextKey = keyboardDelegate.getKeyPageAbove(target.key);\n                let dropPosition = target.dropPosition;\n                if (nextKey == null) {\n                  nextKey = keyboardDelegate.getFirstKey();\n                  dropPosition = 'before';\n                }\n\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n              }\n\n              // If the target does not accept the drop, find the previous valid target.\n              // If no next valid target, find the next valid target.\n              let {draggingKeys} = globalDndState;\n              let isInternal = isInternalDropOperation(ref);\n              let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n              if (operation === 'cancel') {\n                target = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)\n                  ?? nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);\n              }\n            }\n\n            localState.state.setTarget(target ?? localState.state.target);\n            break;\n          }\n        }\n      }\n    });\n  }, [localState, ref, onDrop, direction]);\n\n  let id = useId();\n  droppableCollectionMap.set(state, {id, ref});\n  return {\n    collectionProps: mergeProps(dropProps, {\n      id,\n      // Remove description from collection element. If dropping on the entire collection,\n      // there should be a drop indicator that has this description, so no need to double announce.\n      'aria-describedby': null\n    })\n  };\n}\n"],"names":[],"version":3,"file":"useDroppableCollection.module.js.map"}