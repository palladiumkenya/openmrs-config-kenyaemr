{"mappings":"AA8BO,MAAM;IAeH,gBAAgB,IAAa,EAAE;QACrC,OAAO,IAAI,CAAC,WAAW,KAAK,eAAe,KAAK,IAAI,GAAG,KAAK,GAAG;IACjE;IAEQ,cAAc,IAAa,EAAE;QACnC,OAAO,IAAI,CAAC,WAAW,KAAK,eAAe,KAAK,KAAK,GAAG,KAAK,MAAM;IACrE;IAEQ,kBAAkB,IAAa,EAAE;QACvC,OAAO,IAAI,CAAC,WAAW,KAAK,eAAe,KAAK,GAAG,GAAG,KAAK,IAAI;IACjE;IAEQ,gBAAgB,IAAa,EAAE;QACrC,OAAO,IAAI,CAAC,WAAW,KAAK,eAAe,KAAK,MAAM,GAAG,KAAK,KAAK;IACrE;IAEQ,aAAa,IAAa,EAAE;QAClC,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU,IAAI,CAAC,eAAe,CAAC,QAAQ,IAAI,CAAC,iBAAiB,CAAC;IACvF;IAEQ,WAAW,IAAa,EAAE;QAChC,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU,IAAI,CAAC,aAAa,CAAC,QAAQ,IAAI,CAAC,eAAe,CAAC;IACnF;IAEQ,YAAY,IAAa,EAAE;QACjC,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,IAAI,CAAC,YAAY,CAAC;IACnD;IAEA,uBAAuB,CAAS,EAAE,CAAS,EAAE,iBAAkD,EAAc;QAC3G,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,QAAQ,CAAC,GAAG,IAAI,GAAG,IAAI,EAChD,OAAO;YAAC,MAAM;QAAM;QAGtB,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,qBAAqB;QACjD,IAAI,UAAU,IAAI,CAAC,WAAW,KAAK,eAAe,IAAI;QACtD,IAAI,YAAY,IAAI,CAAC,WAAW,KAAK,eAAe,IAAI;QACxD,WAAW,IAAI,CAAC,eAAe,CAAC;QAChC,aAAa,IAAI,CAAC,iBAAiB,CAAC;QAEpC,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU,UAAU;QAC/C,IAAI,eAAe,IAAI,CAAC,WAAW,KAAK,gBAAgB,IAAI,CAAC,SAAS,KAAK;QAC3E,IAAI,iBAAiB,IAAI,CAAC,MAAM,KAAK,UAAU,IAAI,CAAC,WAAW,KAAK,cAAc,IAAI,CAAC,SAAS,KAAK;QACrG,IAAI,YAAY,IAAI,CAAC,MAAM,KAAK,UAAU,eAAe;QAEzD,IAAI,WAAW,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,gBAAgB,CAAC;QACjD,IAAI,aAAa,IAAI;QACrB,KAAK,IAAI,QAAQ,SACf,IAAI,gBAAgB,aAClB,WAAW,GAAG,CAAC,KAAK,OAAO,CAAC,GAAG,EAAE;QAIrC,0HAA0H;QAC1H,wJAAwJ;QACxJ,6JAA6J;QAC7J,+BAA+B;QAC/B,IAAI,QAAQ;eAAI,IAAI,CAAC,UAAU;SAAC,CAAC,MAAM,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;QAC9D,IAAI,MAAM;QACV,IAAI,OAAO,MAAM,MAAM;QACvB,MAAO,MAAM,KAAM;YACjB,IAAI,MAAM,KAAK,KAAK,CAAC,AAAC,CAAA,MAAM,IAAG,IAAK;YACpC,IAAI,OAAO,KAAK,CAAC,IAAI;YACrB,IAAI,UAAU,WAAW,GAAG,CAAC,OAAO,KAAK,GAAG;YAC5C,IAAI,OAAO,QAAQ,qBAAqB;YACxC,IAAI,SAAS,CAAC;gBACZ,IAAI,WACF,MAAM,MAAM;qBAEZ,OAAO;YAEX;YAEA,IAAI,UAAU,IAAI,CAAC,eAAe,CAAC,OACjC,OAAO;iBACF,IAAI,UAAU,IAAI,CAAC,aAAa,CAAC,OACtC,OAAO,CAAC;iBACH,IAAI,YAAY,IAAI,CAAC,iBAAiB,CAAC,OAC5C,OAAO;iBACF,IAAI,YAAY,IAAI,CAAC,eAAe,CAAC,OAC1C,OAAO,CAAC;iBACH;gBACL,IAAI,SAAqB;oBACvB,MAAM;oBACN,KAAK,KAAK,GAAG;oBACb,cAAc;gBAChB;gBAEA,IAAI,kBAAkB,SAAS;oBAC7B,+FAA+F;oBAC/F,mCAAmC;oBACnC,IAAI,QAAQ,IAAI,CAAC,YAAY,CAAC,QAAQ,KAAK,kBAAkB;wBAAC,GAAG,MAAM;wBAAE,cAAc;oBAAQ,IAC7F,OAAO,YAAY,GAAG,YAAY,UAAU;yBACvC,IAAI,QAAQ,IAAI,CAAC,UAAU,CAAC,QAAQ,KAAK,kBAAkB;wBAAC,GAAG,MAAM;wBAAE,cAAc;oBAAO,IACjG,OAAO,YAAY,GAAG,YAAY,WAAW;gBAEjD,OAAO;oBACL,oGAAoG;oBACpG,IAAI,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,IAAI,CAAC,WAAW,CAAC,QAAQ;oBAC7D,IAAI,QAAQ,OAAO,kBAAkB;wBAAC,GAAG,MAAM;wBAAE,cAAc;oBAAQ,IACrE,OAAO,YAAY,GAAG,YAAY,UAAU;yBACvC,IAAI,QAAQ,OAAO,kBAAkB;wBAAC,GAAG,MAAM;wBAAE,cAAc;oBAAO,IAC3E,OAAO,YAAY,GAAG,YAAY,WAAW;gBAEjD;gBAEA,OAAO;YACT;QACF;QAEA,IAAI,OAAO,KAAK,CAAC,KAAK,GAAG,CAAC,KAAK,MAAM,MAAM,GAAG,GAAG;QACjD,IAAI,UAAU,WAAW,GAAG,CAAC,OAAO,KAAK,GAAG;QAC5C,OAAO,QAAQ,qBAAqB;QAEpC,IAAI,UAAU,IAAI,CAAC,eAAe,CAAC,SAAS,KAAK,GAAG,CAAC,OAAO,IAAI,CAAC,YAAY,CAAC,SAAS,KAAK,GAAG,CAAC,OAAO,IAAI,CAAC,UAAU,CAAC,QACrH,OAAO;YACL,MAAM;YACN,KAAK,KAAK,GAAG;YACb,cAAc,YAAY,UAAU;QACtC;QAGF,OAAO;YACL,MAAM;YACN,KAAK,KAAK,GAAG;YACb,cAAc,YAAY,WAAW;QACvC;IACF;IAtIA,YAAY,UAAmC,EAAE,GAAkC,EAAE,OAAuC,CAAE;QAC5H,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,MAAM,GAAG,CAAA,oBAAA,8BAAA,QAAS,MAAM,KAAI;QACjC,IAAI,CAAC,WAAW,GAAG,CAAA,oBAAA,8BAAA,QAAS,WAAW,KAAI;QAC3C,IAAI,CAAC,SAAS,GAAG,CAAA,oBAAA,8BAAA,QAAS,SAAS,KAAI;IACzC;AAiIF","sources":["packages/@react-aria/dnd/src/ListDropTargetDelegate.ts"],"sourcesContent":["import {Direction, DropTarget, DropTargetDelegate, Node, Orientation, RefObject} from '@react-types/shared';\n\ninterface ListDropTargetDelegateOptions {\n  /**\n   * Whether the items are arranged in a stack or grid.\n   * @default 'stack'\n   */\n  layout?: 'stack' | 'grid',\n  /**\n   * The primary orientation of the items. Usually this is the\n   * direction that the collection scrolls.\n   * @default 'vertical'\n   */\n  orientation?: Orientation,\n  /**\n   * The horizontal layout direction.\n   * @default 'ltr'\n   */\n  direction?: Direction\n}\n\n// Terms used in the below code:\n//   * \"Primary\"   – The main layout direction. For stacks, this is the direction\n//                   that the stack is arranged in (e.g. horizontal or vertical).\n//                   For grids, this is the main scroll direction.\n//   * \"Secondary\" – The secondary layout direction. For stacks, there is no secondary\n//                   layout direction. For grids, this is the opposite of the primary direction.\n//   * \"Flow\"      – The flow direction of the items. For stacks, this is the the primary\n//                   direction. For grids, it is the secondary direction.\n\nexport class ListDropTargetDelegate implements DropTargetDelegate {\n  private collection: Iterable<Node<unknown>>;\n  private ref: RefObject<HTMLElement | null>;\n  private layout: 'stack' | 'grid';\n  private orientation: Orientation;\n  private direction: Direction;\n\n  constructor(collection: Iterable<Node<unknown>>, ref: RefObject<HTMLElement | null>, options?: ListDropTargetDelegateOptions) {\n    this.collection = collection;\n    this.ref = ref;\n    this.layout = options?.layout || 'stack';\n    this.orientation = options?.orientation || 'vertical';\n    this.direction = options?.direction || 'ltr';\n  }\n\n  private getPrimaryStart(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.left : rect.top;\n  }\n\n  private getPrimaryEnd(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.right : rect.bottom;\n  }\n\n  private getSecondaryStart(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.top : rect.left;\n  }\n\n  private getSecondaryEnd(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.bottom : rect.right;\n  }\n\n  private getFlowStart(rect: DOMRect) {\n    return this.layout === 'stack' ? this.getPrimaryStart(rect) : this.getSecondaryStart(rect);\n  }\n\n  private getFlowEnd(rect: DOMRect) {\n    return this.layout === 'stack' ? this.getPrimaryEnd(rect) : this.getSecondaryEnd(rect);\n  }\n\n  private getFlowSize(rect: DOMRect) {\n    return this.getFlowEnd(rect) - this.getFlowStart(rect);\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    if (this.collection[Symbol.iterator]().next().done) {\n      return {type: 'root'};\n    }\n\n    let rect = this.ref.current.getBoundingClientRect();\n    let primary = this.orientation === 'horizontal' ? x : y;\n    let secondary = this.orientation === 'horizontal' ? y : x;\n    primary += this.getPrimaryStart(rect);\n    secondary += this.getSecondaryStart(rect);\n\n    let flow = this.layout === 'stack' ? primary : secondary;\n    let isPrimaryRTL = this.orientation === 'horizontal' && this.direction === 'rtl';\n    let isSecondaryRTL = this.layout === 'grid' && this.orientation === 'vertical' && this.direction === 'rtl';\n    let isFlowRTL = this.layout === 'stack' ? isPrimaryRTL : isSecondaryRTL;\n\n    let elements = this.ref.current.querySelectorAll('[data-key]');\n    let elementMap = new Map<string, HTMLElement>();\n    for (let item of elements) {\n      if (item instanceof HTMLElement) {\n        elementMap.set(item.dataset.key, item);\n      }\n    }\n\n    // TODO: assume that only item type items are valid drop targets. This is to prevent a crash when dragging over the loader\n    // row since it doesn't have a data-key set on it. Will eventually need to handle the case with drag and drop and loaders located between rows aka tree.\n    // Can see https://github.com/adobe/react-spectrum/pull/4210/files#diff-21e555e0c597a28215e36137f5be076a65a1e1456c92cd0fdd60f866929aae2a for additional logic\n    // that may need to happen then\n    let items = [...this.collection].filter(item => item.type === 'item');\n    let low = 0;\n    let high = items.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      let item = items[mid];\n      let element = elementMap.get(String(item.key));\n      let rect = element.getBoundingClientRect();\n      let update = (isGreater: boolean) => {\n        if (isGreater) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      };\n\n      if (primary < this.getPrimaryStart(rect)) {\n        update(isPrimaryRTL);\n      } else if (primary > this.getPrimaryEnd(rect)) {\n        update(!isPrimaryRTL);\n      } else if (secondary < this.getSecondaryStart(rect)) {\n        update(isSecondaryRTL);\n      } else if (secondary > this.getSecondaryEnd(rect)) {\n        update(!isSecondaryRTL);\n      } else {\n        let target: DropTarget = {\n          type: 'item',\n          key: item.key,\n          dropPosition: 'on'\n        };\n\n        if (isValidDropTarget(target)) {\n          // Otherwise, if dropping on the item is accepted, try the before/after positions if within 5px\n          // of the start or end of the item.\n          if (flow <= this.getFlowStart(rect) + 5 && isValidDropTarget({...target, dropPosition: 'before'})) {\n            target.dropPosition = isFlowRTL ? 'after' : 'before';\n          } else if (flow >= this.getFlowEnd(rect) - 5 && isValidDropTarget({...target, dropPosition: 'after'})) {\n            target.dropPosition = isFlowRTL ? 'before' : 'after';\n          }\n        } else {\n          // If dropping on the item isn't accepted, try the target before or after depending on the position.\n          let mid = this.getFlowStart(rect) + this.getFlowSize(rect) / 2;\n          if (flow <= mid && isValidDropTarget({...target, dropPosition: 'before'})) {\n            target.dropPosition = isFlowRTL ? 'after' : 'before';\n          } else if (flow >= mid && isValidDropTarget({...target, dropPosition: 'after'})) {\n            target.dropPosition = isFlowRTL ? 'before' : 'after';\n          }\n        }\n\n        return target;\n      }\n    }\n\n    let item = items[Math.min(low, items.length - 1)];\n    let element = elementMap.get(String(item.key));\n    rect = element.getBoundingClientRect();\n\n    if (primary < this.getPrimaryStart(rect) || Math.abs(flow - this.getFlowStart(rect)) < Math.abs(flow - this.getFlowEnd(rect))) {\n      return {\n        type: 'item',\n        key: item.key,\n        dropPosition: isFlowRTL ? 'after' : 'before'\n      };\n    }\n\n    return {\n      type: 'item',\n      key: item.key,\n      dropPosition: isFlowRTL ? 'before' : 'after'\n    };\n  }\n}\n"],"names":[],"version":3,"file":"ListDropTargetDelegate.module.js.map"}