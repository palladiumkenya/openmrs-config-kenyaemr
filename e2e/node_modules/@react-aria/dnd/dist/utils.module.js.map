{"mappings":"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","sources":["packages/@react-aria/dnd/src/utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CUSTOM_DRAG_TYPE, DROP_OPERATION, GENERIC_TYPE, NATIVE_DRAG_TYPES} from './constants';\nimport {DirectoryDropItem, DragItem, DropItem, FileDropItem, DragTypes as IDragTypes, Key, RefObject, TextDropItem} from '@react-types/shared';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {getInteractionModality, useInteractionModality} from '@react-aria/interactions';\n\ninterface DroppableCollectionMap {\n  id: string,\n  ref: RefObject<HTMLElement | null>\n}\n\nexport const droppableCollectionMap = new WeakMap<DroppableCollectionState, DroppableCollectionMap>();\nexport const DIRECTORY_DRAG_TYPE = Symbol();\n\nexport function getDroppableCollectionId(state: DroppableCollectionState) {\n  let {id} = droppableCollectionMap.get(state);\n  if (!id) {\n    throw new Error('Droppable item outside a droppable collection');\n  }\n\n  return id;\n}\n\nexport function getDroppableCollectionRef(state: DroppableCollectionState) {\n  let {ref} = droppableCollectionMap.get(state);\n  if (!ref) {\n    throw new Error('Droppable item outside a droppable collection');\n  }\n\n  return ref;\n}\n\nexport function getTypes(items: DragItem[]): Set<string> {\n  let types = new Set<string>();\n  for (let item of items) {\n    for (let type of Object.keys(item)) {\n      types.add(type);\n    }\n  }\n\n  return types;\n}\n\nfunction mapModality(modality: string) {\n  if (!modality) {\n    modality = 'virtual';\n  }\n\n  if (modality === 'pointer') {\n    modality = 'virtual';\n  }\n\n  if (modality === 'virtual' &&  (typeof window !== 'undefined' && 'ontouchstart' in window)) {\n    modality = 'touch';\n  }\n\n  return modality;\n}\n\nexport function useDragModality() {\n  return mapModality(useInteractionModality());\n}\n\nexport function getDragModality() {\n  return mapModality(getInteractionModality());\n}\n\nexport function writeToDataTransfer(dataTransfer: DataTransfer, items: DragItem[]) {\n  // The data transfer API doesn't support more than one item of a given type at once.\n  // In addition, only a small set of types are supported natively for transfer between applications.\n  // We allow for both multiple items, as well as multiple representations of a single item.\n  // In order to make our API work with the native API, we serialize all items to JSON and\n  // store as a single native item. We only need to do this if there is more than one item\n  // of the same type, or if an item has more than one representation. Otherwise the native\n  // API is sufficient.\n  //\n  // The DataTransferItemList API also theoretically supports adding files, which would enable\n  // dragging binary data out of the browser onto the user's desktop for example. Unfortunately,\n  // this does not currently work in any browser, so it is not currently supported by our API.\n  // See e.g. https://bugs.chromium.org/p/chromium/issues/detail?id=438479.\n  let groupedByType = new Map<string, string[]>();\n  let needsCustomData = false;\n  let customData = [];\n  for (let item of items) {\n    let types = Object.keys(item);\n    if (types.length > 1) {\n      needsCustomData = true;\n    }\n\n    let dataByType = {};\n    for (let type of types) {\n      let typeItems = groupedByType.get(type);\n      if (!typeItems) {\n        typeItems = [];\n        groupedByType.set(type, typeItems);\n      } else {\n        needsCustomData = true;\n      }\n\n      let data = item[type];\n      dataByType[type] = data;\n      typeItems.push(data);\n    }\n\n    customData.push(dataByType);\n  }\n\n  for (let [type, items] of groupedByType) {\n    if (NATIVE_DRAG_TYPES.has(type)) {\n      // Only one item of a given type can be set on a data transfer.\n      // Join all of the items together separated by newlines.\n      let data = items.join('\\n');\n      dataTransfer.items.add(data, type);\n    } else {\n      // Set data to the first item so we have access to the list of types.\n      dataTransfer.items.add(items[0], type);\n    }\n  }\n\n  if (needsCustomData) {\n    let data = JSON.stringify(customData);\n    dataTransfer.items.add(data, CUSTOM_DRAG_TYPE);\n  }\n}\n\nexport class DragTypes implements IDragTypes {\n  private types: Set<string>;\n  private includesUnknownTypes: boolean;\n\n  constructor(dataTransfer: DataTransfer) {\n    this.types = new Set<string>();\n\n    let hasFiles = false;\n    for (let item of dataTransfer.items) {\n      if (item.type !== CUSTOM_DRAG_TYPE) {\n        if (item.kind === 'file') {\n          hasFiles = true;\n        }\n\n        if (item.type) {\n          this.types.add(item.type);\n        } else {\n          // Files with unknown types or extensions that don't map to a known mime type\n          // are sometimes exposed as an empty string by the browser. Map to a generic\n          // mime type instead. Note that this could also be a directory as there's no\n          // way to determine if something is a file or directory until drop.\n          this.types.add(GENERIC_TYPE);\n        }\n      }\n    }\n\n    // In Safari, when dragging files, the dataTransfer.items list is empty, but dataTransfer.types contains \"Files\".\n    // Unfortunately, this doesn't tell us what types of files the user is dragging, so we need to assume that any\n    // type the user checks for is included. See https://bugs.webkit.org/show_bug.cgi?id=223517.\n    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes('Files');\n  }\n\n  has(type: string | symbol) {\n    if (this.includesUnknownTypes || (type === DIRECTORY_DRAG_TYPE && this.types.has(GENERIC_TYPE))) {\n      return true;\n    }\n\n    return typeof type === 'string' && this.types.has(type);\n  }\n}\n\nexport function readFromDataTransfer(dataTransfer: DataTransfer) {\n  let items: DropItem[] = [];\n\n  // If our custom drag type is available, use that. This is a JSON serialized\n  // representation of all items in the drag, set when there are multiple items\n  // of the same type, or an individual item has multiple representations.\n  let hasCustomType = false;\n  if (dataTransfer.types.includes(CUSTOM_DRAG_TYPE)) {\n    try {\n      let data = dataTransfer.getData(CUSTOM_DRAG_TYPE);\n      let parsed = JSON.parse(data);\n      for (let item of parsed) {\n        items.push({\n          kind: 'text',\n          types: new Set(Object.keys(item)),\n          getText: (type) => Promise.resolve(item[type])\n        });\n      }\n\n      hasCustomType = true;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // Otherwise, map native drag items to items of a single representation.\n  if (!hasCustomType) {\n    let stringItems = new Map();\n    for (let item of dataTransfer.items) {\n      if (item.kind === 'string') {\n        // The data for all formats must be read here because the data transfer gets\n        // cleared out after the event handler finishes. If the item has an empty string\n        // as a type, the mime type is unknown. Map to a generic mime type instead.\n        stringItems.set(item.type || GENERIC_TYPE, dataTransfer.getData(item.type));\n      } else if (item.kind === 'file') {\n        // Despite the name, webkitGetAsEntry is also implemented in Firefox and Edge.\n        // In the future, we may use getAsFileSystemHandle instead, but that's currently\n        // only implemented in Chrome.\n        if (typeof item.webkitGetAsEntry === 'function') {\n          let entry: FileSystemEntry = item.webkitGetAsEntry();\n          // eslint-disable-next-line max-depth\n          if (!entry) {\n            // For some reason, Firefox includes an item with type image/png when copy\n            // and pasting any file or directory (no matter the type), but returns `null` for both\n            // item.getAsFile() and item.webkitGetAsEntry(). Safari works as expected. Ignore this\n            // item if this happens. See https://bugzilla.mozilla.org/show_bug.cgi?id=1699743.\n            // This was recently fixed in Chrome Canary: https://bugs.chromium.org/p/chromium/issues/detail?id=1175483.\n            continue;\n          }\n\n          // eslint-disable-next-line max-depth\n          if (entry.isFile) {\n            items.push(createFileItem(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            items.push(createDirectoryItem(entry));\n          }\n        } else {\n          // Assume it's a file.\n          items.push(createFileItem(item.getAsFile()));\n        }\n      }\n    }\n\n    // All string items are different representations of the same item. There's no way to have\n    // multiple string items at once in the current DataTransfer API.\n    if (stringItems.size > 0) {\n      items.push({\n        kind: 'text',\n        types: new Set(stringItems.keys()),\n        getText: (type) => Promise.resolve(stringItems.get(type))\n      });\n    }\n  }\n\n  return items;\n}\n\nfunction blobToString(blob: Blob): Promise<string> {\n  if (typeof blob.text === 'function') {\n    return blob.text();\n  }\n\n  // Safari doesn't have the Blob#text() method yet...\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader;\n    reader.onload = () => {\n      resolve(reader.result as string);\n    };\n\n    reader.onerror = reject;\n    reader.readAsText(blob);\n  });\n}\n\nfunction createFileItem(file: File): FileDropItem {\n  return {\n    kind: 'file',\n    type: file.type || GENERIC_TYPE,\n    name: file.name,\n    getText: () => blobToString(file),\n    getFile: () => Promise.resolve(file)\n  };\n}\n\nfunction createDirectoryItem(entry: any): DirectoryDropItem {\n  return {\n    kind: 'directory',\n    name: entry.name,\n    getEntries: () => getEntries(entry)\n  };\n}\n\nasync function *getEntries(item: FileSystemDirectoryEntry): AsyncIterable<FileDropItem | DirectoryDropItem> {\n  let reader = item.createReader();\n\n  // We must call readEntries repeatedly because there may be a limit to the\n  // number of entries that are returned at once.\n  let entries: FileSystemEntry[];\n  do {\n    entries = await new Promise((resolve, reject) => {\n      reader.readEntries(resolve, reject);\n    });\n\n    for (let entry of entries) {\n      if (entry.isFile) {\n        let file = await getEntryFile(entry as FileSystemFileEntry);\n        yield createFileItem(file);\n      } else if (entry.isDirectory) {\n        yield createDirectoryItem(entry);\n      }\n    }\n  } while (entries.length > 0);\n}\n\nfunction getEntryFile(entry: FileSystemFileEntry): Promise<File> {\n  return new Promise((resolve, reject) => entry.file(resolve, reject));\n}\n\n/** Returns whether a drop item contains text data. */\nexport function isTextDropItem(dropItem: DropItem): dropItem is TextDropItem {\n  return dropItem.kind === 'text';\n}\n\n/** Returns whether a drop item is a file. */\nexport function isFileDropItem(dropItem: DropItem): dropItem is FileDropItem {\n  return dropItem.kind === 'file';\n}\n\n/** Returns whether a drop item is a directory. */\nexport function isDirectoryDropItem(dropItem: DropItem): dropItem is DirectoryDropItem {\n  return dropItem.kind === 'directory';\n}\n\n// Global DnD collection state tracker.\nexport interface DnDState {\n  /** A ref for the  of the drag items in the current drag session if any. */\n  draggingCollectionRef?: RefObject<HTMLElement | null>,\n  /** The set of currently dragged keys. */\n  draggingKeys: Set<Key>,\n  /** A ref for the collection that is targeted for a drop operation, if any. */\n  dropCollectionRef?: RefObject<HTMLElement | null>\n}\n\nexport let globalDndState: DnDState = {draggingKeys: new Set()};\n\nexport function setDraggingCollectionRef(ref: RefObject<HTMLElement | null>) {\n  globalDndState.draggingCollectionRef = ref;\n}\n\nexport function setDraggingKeys(keys: Set<Key>) {\n  globalDndState.draggingKeys = keys;\n}\n\nexport function setDropCollectionRef(ref: RefObject<HTMLElement | null>) {\n  globalDndState.dropCollectionRef = ref;\n}\n\nexport function clearGlobalDnDState() {\n  globalDndState = {draggingKeys: new Set()};\n}\n\nexport function setGlobalDnDState(state: DnDState) {\n  globalDndState = state;\n}\n\n// Util function to check if the current dragging collection ref is the same as the current targeted droppable collection ref.\n// Allows a droppable ref arg in case the global drop collection ref hasn't been set\nexport function isInternalDropOperation(ref?: RefObject<HTMLElement | null>) {\n  let {draggingCollectionRef, dropCollectionRef} = globalDndState;\n  return draggingCollectionRef?.current != null && draggingCollectionRef.current === (ref?.current || dropCollectionRef?.current);\n}\n\ntype DropEffect = 'none' | 'copy' | 'link' | 'move';\nexport let globalDropEffect: DropEffect;\nexport function setGlobalDropEffect(dropEffect: DropEffect) {\n  globalDropEffect = dropEffect;\n}\n\nexport let globalAllowedDropOperations = DROP_OPERATION.none;\nexport function setGlobalAllowedDropOperations(o: DROP_OPERATION) {\n  globalAllowedDropOperations = o;\n}\n"],"names":[],"version":3,"file":"utils.module.js.map"}