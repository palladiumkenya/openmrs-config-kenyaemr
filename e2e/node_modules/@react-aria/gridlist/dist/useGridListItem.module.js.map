{"mappings":"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","sources":["packages/@react-aria/gridlist/src/useGridListItem.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, mergeProps, scrollIntoViewport, useSlotId, useSyntheticLinkProps} from '@react-aria/utils';\nimport {DOMAttributes, FocusableElement, RefObject, Node as RSNode} from '@react-types/shared';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {getLastItem} from '@react-stately/collections';\nimport {getRowId, listMap} from './utils';\nimport {HTMLAttributes, KeyboardEvent as ReactKeyboardEvent, useRef} from 'react';\nimport {isFocusVisible} from '@react-aria/interactions';\nimport type {ListState} from '@react-stately/list';\nimport {SelectableItemStates, useSelectableItem} from '@react-aria/selection';\nimport type {TreeState} from '@react-stately/tree';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface AriaGridListItemOptions {\n  /** An object representing the list item. Contains all the relevant information that makes up the list row. */\n  node: RSNode<unknown>,\n  /** Whether the list row is contained in a virtual scroller. */\n  isVirtualized?: boolean,\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean\n}\n\nexport interface GridListItemAria extends SelectableItemStates {\n  /** Props for the list row element. */\n  rowProps: DOMAttributes,\n  /** Props for the grid cell element within the list row. */\n  gridCellProps: DOMAttributes,\n  /** Props for the list item description element, if any. */\n  descriptionProps: DOMAttributes\n}\n\nconst EXPANSION_KEYS = {\n  'expand': {\n    ltr: 'ArrowRight',\n    rtl: 'ArrowLeft'\n  },\n  'collapse': {\n    ltr: 'ArrowLeft',\n    rtl: 'ArrowRight'\n  }\n};\n\n/**\n * Provides the behavior and accessibility implementation for a row in a grid list.\n * @param props - Props for the row.\n * @param state - State of the parent list, as returned by `useListState`.\n * @param ref - The ref attached to the row element.\n */\nexport function useGridListItem<T>(props: AriaGridListItemOptions, state: ListState<T> | TreeState<T>, ref: RefObject<FocusableElement | null>): GridListItemAria {\n  // Copied from useGridCell + some modifications to make it not so grid specific\n  let {\n    node,\n    isVirtualized,\n    shouldSelectOnPressUp\n  } = props;\n\n  // let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/gridlist');\n  let {direction} = useLocale();\n  let {onAction, linkBehavior, keyboardNavigationBehavior} = listMap.get(state);\n  let descriptionId = useSlotId();\n\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = useRef(null);\n  let focus = () => {\n    // Don't shift focus to the row if the active element is a element within the row already\n    // (e.g. clicking on a row button)\n    if (\n      (keyWhenFocused.current != null && node.key !== keyWhenFocused.current) ||\n      !ref.current?.contains(document.activeElement)\n    ) {\n      focusSafely(ref.current);\n    }\n  };\n\n  let treeGridRowProps: HTMLAttributes<HTMLElement> = {};\n  let hasChildRows;\n  let hasLink = state.selectionManager.isLink(node.key);\n  if (node != null && 'expandedKeys' in state) {\n    // TODO: ideally node.hasChildNodes would be a way to tell if a row has child nodes, but the row's contents make it so that value is always\n    // true...\n    hasChildRows = [...state.collection.getChildren(node.key)].length > 1;\n    if (onAction == null && !hasLink && state.selectionManager.selectionMode === 'none' && hasChildRows) {\n      onAction = () => state.toggleKey(node.key);\n    }\n\n    let isExpanded = hasChildRows ? state.expandedKeys.has(node.key) : undefined;\n    treeGridRowProps = {\n      'aria-expanded': isExpanded,\n      'aria-level': node.level + 1,\n      'aria-posinset': node?.index + 1,\n      'aria-setsize': node.level > 0 ?\n        (getLastItem(state.collection.getChildren(node?.parentKey))).index + 1 :\n        [...state.collection].filter(row => row.level === 0).at(-1).index + 1\n    };\n  }\n\n  let {itemProps, ...itemStates} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref,\n    isVirtualized,\n    shouldSelectOnPressUp,\n    onAction: onAction || node.props?.onAction ? chain(node.props?.onAction, onAction ? () => onAction(node.key) : undefined) : undefined,\n    focus,\n    linkBehavior\n  });\n\n  let onKeyDown = (e: ReactKeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target as Element)) {\n      return;\n    }\n\n    let walker = getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    if ('expandedKeys' in state && document.activeElement === ref.current) {\n      if ((e.key === EXPANSION_KEYS['expand'][direction]) && state.selectionManager.focusedKey === node.key && hasChildRows && !state.expandedKeys.has(node.key)) {\n        state.toggleKey(node.key);\n        e.stopPropagation();\n        return;\n      } else if ((e.key === EXPANSION_KEYS['collapse'][direction]) && state.selectionManager.focusedKey === node.key && hasChildRows && state.expandedKeys.has(node.key)) {\n        state.toggleKey(node.key);\n        e.stopPropagation();\n        return;\n      }\n    }\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        if (keyboardNavigationBehavior === 'arrow') {\n          // Find the next focusable element within the row.\n          let focusable = direction === 'rtl'\n            ? walker.nextNode() as FocusableElement\n            : walker.previousNode() as FocusableElement;\n\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            focusSafely(focusable);\n            scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n          } else {\n            // If there is no next focusable child, then return focus back to the row\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'rtl') {\n              focusSafely(ref.current);\n              scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n            } else {\n              walker.currentNode = ref.current;\n              let lastElement = last(walker);\n              if (lastElement) {\n                focusSafely(lastElement);\n                scrollIntoViewport(lastElement, {containingElement: getScrollParent(ref.current)});\n              }\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (keyboardNavigationBehavior === 'arrow') {\n          let focusable = direction === 'rtl'\n            ? walker.previousNode() as FocusableElement\n            : walker.nextNode() as FocusableElement;\n\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            focusSafely(focusable);\n            scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n          } else {\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'ltr') {\n              focusSafely(ref.current);\n              scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n            } else {\n              walker.currentNode = ref.current;\n              let lastElement = last(walker);\n              if (lastElement) {\n                focusSafely(lastElement);\n                scrollIntoViewport(lastElement, {containingElement: getScrollParent(ref.current)});\n              }\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate\n        // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target as Element)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          );\n        }\n        break;\n      case 'Tab': {\n        if (keyboardNavigationBehavior === 'tab') {\n          // If there is another focusable element within this item, stop propagation so the tab key\n          // is handled by the browser and not by useSelectableCollection (which would take us out of the list).\n          let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n          walker.currentNode = document.activeElement;\n          let next = e.shiftKey ? walker.previousNode() : walker.nextNode();\n          if (next) {\n            e.stopPropagation();\n          }\n        }\n      }\n    }\n  };\n\n  let onFocus = (e) => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the row itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row\n      // in that case since the list should act like a single tab stop.\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocusedKey(node.key);\n      }\n      return;\n    }\n  };\n\n  let syntheticLinkProps = useSyntheticLinkProps(node.props);\n  let linkProps = itemStates.hasAction ? syntheticLinkProps : {};\n  // TODO: re-add when we get translations and fix this for iOS VO\n  // let rowAnnouncement;\n  // if (onAction) {\n  //   rowAnnouncement = stringFormatter.format('hasActionAnnouncement');\n  // } else if (hasLink) {\n  //   rowAnnouncement = stringFormatter.format('hasLinkAnnouncement', {\n  //     link: node.props.href\n  //   });\n  // }\n\n  let rowProps: DOMAttributes = mergeProps(itemProps, linkProps, {\n    role: 'row',\n    onKeyDownCapture: onKeyDown,\n    onFocus,\n    // 'aria-label': [(node.textValue || undefined), rowAnnouncement].filter(Boolean).join(', '),\n    'aria-label': node.textValue || undefined,\n    'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,\n    'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,\n    'aria-labelledby': descriptionId && node.textValue ? `${getRowId(state, node.key)} ${descriptionId}` : undefined,\n    id: getRowId(state, node.key)\n  });\n\n  if (isVirtualized) {\n    rowProps['aria-rowindex'] = node.index + 1;\n  }\n\n  let gridCellProps = {\n    role: 'gridcell',\n    'aria-colindex': 1\n  };\n\n  // TODO: should isExpanded and hasChildRows be a item state that gets returned by the hook?\n  return {\n    rowProps: {...mergeProps(rowProps, treeGridRowProps)},\n    gridCellProps,\n    descriptionProps: {\n      id: descriptionId\n    },\n    ...itemStates\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n"],"names":[],"version":3,"file":"useGridListItem.module.js.map"}