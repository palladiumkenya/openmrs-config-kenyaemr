{"mappings":"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","sources":["packages/@react-aria/calendar/src/utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, DateFormatter, endOfMonth, isSameDay, startOfMonth} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport type {LocalizedStringFormatter} from '@internationalized/string';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useMemo} from 'react';\n\ninterface HookData {\n  ariaLabel: string,\n  ariaLabelledBy: string,\n  errorMessageId: string,\n  selectedDateDescription: string\n}\n\nexport const hookData = new WeakMap<CalendarState | RangeCalendarState, HookData>();\n\nexport function getEraFormat(date: CalendarDate): 'short' | undefined {\n  return date?.calendar.identifier === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\n\nexport function useSelectedDateDescription(state: CalendarState | RangeCalendarState) {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n\n  let start: CalendarDate, end: CalendarDate;\n  if ('highlightedRange' in state) {\n    ({start, end} = state.highlightedRange || {});\n  } else {\n    start = end = state.value;\n  }\n\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: getEraFormat(start) || getEraFormat(end),\n    timeZone: state.timeZone\n  });\n\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return useMemo(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if (isSameDay(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {date});\n      } else {\n        let dateRange = formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n\n        return stringFormatter.format('selectedRangeDescription', {dateRange});\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\n\nexport function useVisibleRangeDescription(startDate: CalendarDate, endDate: CalendarDate, timeZone: string, isAria: boolean) {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let era: any = getEraFormat(startDate) || getEraFormat(endDate);\n  let monthFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  let dateFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  return useMemo(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if (isSameDay(startDate, startOfMonth(startDate))) {\n      if (isSameDay(endDate, endOfMonth(startDate))) {\n        return monthFormatter.format(startDate.toDate(timeZone));\n      } else if (isSameDay(endDate, endOfMonth(endDate))) {\n        return isAria\n          ? formatRange(monthFormatter, stringFormatter, startDate, endDate, timeZone)\n          : monthFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n      }\n    }\n\n    return isAria\n      ? formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone)\n      : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\n\nfunction formatRange(dateFormatter: DateFormatter, stringFormatter: LocalizedStringFormatter, start: CalendarDate, end: CalendarDate, timeZone: string) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') {\n      separatorIndex = i;\n    } else if (part.source === 'endRange') {\n      break;\n    }\n  }\n\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) {\n      startValue += parts[i].value;\n    } else if (i > separatorIndex) {\n      endValue += parts[i].value;\n    }\n  }\n\n  return stringFormatter.format('dateRange', {startDate: startValue, endDate: endValue});\n}\n"],"names":[],"version":3,"file":"utils.module.js.map"}