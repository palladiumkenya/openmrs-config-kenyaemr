{"mappings":"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","sources":["packages/@react-stately/datepicker/src/useDateFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, DateFormatter, getMinimumDayInMonth, getMinimumMonthInYear, GregorianCalendar, toCalendar} from '@internationalized/date';\nimport {convertValue, createPlaceholderDate, FieldOptions, FormatterOptions, getFormatOptions, getValidationResult, useDefaultProps} from './utils';\nimport {DatePickerProps, DateValue, Granularity} from '@react-types/datepicker';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {getPlaceholder} from './placeholders';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport type SegmentType = 'era' | 'year' | 'month' | 'day' |  'hour' | 'minute' | 'second' | 'dayPeriod' | 'literal' | 'timeZoneName';\nexport interface DateSegment {\n  /** The type of segment. */\n  type: SegmentType,\n  /** The formatted text for the segment. */\n  text: string,\n  /** The numeric value for the segment, if applicable. */\n  value?: number,\n  /** The minimum numeric value for the segment, if applicable. */\n  minValue?: number,\n  /** The maximum numeric value for the segment, if applicable. */\n  maxValue?: number,\n  /** Whether the value is a placeholder. */\n  isPlaceholder: boolean,\n  /** A placeholder string for the segment. */\n  placeholder: string,\n  /** Whether the segment is editable. */\n  isEditable: boolean\n}\n\nexport interface DateFieldState extends FormValidationState {\n  /** The current field value. */\n  value: DateValue,\n  /** The current value, converted to a native JavaScript `Date` object.  */\n  dateValue: Date,\n  /** The calendar system currently in use. */\n  calendar: Calendar,\n  /** Sets the field's value. */\n  setValue(value: DateValue): void,\n  /** A list of segments for the current value. */\n  segments: DateSegment[],\n  /** A date formatter configured for the current locale and format. */\n  dateFormatter: DateFormatter,\n  /**\n   * The current validation state of the date field, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState,\n  /** Whether the date field is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** The maximum date or time unit that is displayed in the field. */\n  maxGranularity: 'year' | 'month' | Granularity,\n  /** Whether the field is disabled. */\n  isDisabled: boolean,\n  /** Whether the field is read only. */\n  isReadOnly: boolean,\n  /** Whether the field is required. */\n  isRequired: boolean,\n  /** Increments the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  increment(type: SegmentType): void,\n  /** Decrements the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  decrement(type: SegmentType): void,\n  /**\n   * Increments the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to increment by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  incrementPage(type: SegmentType): void,\n  /**\n   * Decrements the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to decrement by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  decrementPage(type: SegmentType): void,\n  /** Sets the value of the given segment. */\n  setSegment(type: 'era', value: string): void,\n  setSegment(type: SegmentType, value: number): void,\n  /** Updates the remaining unfilled segments with the placeholder value. */\n  confirmPlaceholder(): void,\n  /** Clears the value of the given segment, reverting it to the placeholder. */\n  clearSegment(type: SegmentType): void,\n  /** Formats the current date value using the given options. */\n  formatValue(fieldOptions: FieldOptions): string,\n  /** Gets a formatter based on state's props. */\n  getDateFormatter(locale: string, formatOptions: FormatterOptions): DateFormatter\n}\n\nconst EDITABLE_SEGMENTS = {\n  year: true,\n  month: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true,\n  dayPeriod: true,\n  era: true\n};\n\nconst PAGE_STEP = {\n  year: 5,\n  month: 2,\n  day: 7,\n  hour: 2,\n  minute: 15,\n  second: 15\n};\n\n// Node seems to convert everything to lowercase...\nconst TYPE_MAPPING = {\n  dayperiod: 'dayPeriod'\n};\n\nexport interface DateFieldStateOptions<T extends DateValue = DateValue> extends DatePickerProps<T> {\n  /**\n   * The maximum unit to display in the date field.\n   * @default 'year'\n   */\n  maxGranularity?: 'year' | 'month' | Granularity,\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar\n}\n\n/**\n * Provides state management for a date field component.\n * A date field allows users to enter and edit date and time values using a keyboard.\n * Each part of a date value is displayed in an individually editable segment.\n */\nexport function useDateFieldState<T extends DateValue = DateValue>(props: DateFieldStateOptions<T>): DateFieldState {\n  let {\n    locale,\n    createCalendar,\n    hideTimeZone,\n    isDisabled,\n    isReadOnly,\n    isRequired,\n    minValue,\n    maxValue,\n    isDateUnavailable\n  } = props;\n\n  let v: DateValue = (props.value || props.defaultValue || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let timeZone = defaultTimeZone || 'UTC';\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let defaultFormatter = useMemo(() => new DateFormatter(locale), [locale]);\n  let calendar = useMemo(() => createCalendar(defaultFormatter.resolvedOptions().calendar), [createCalendar, defaultFormatter]);\n\n  let [value, setDate] = useControlledState<DateValue>(\n    props.value,\n    props.defaultValue,\n    props.onChange\n  );\n\n  let calendarValue = useMemo(() => convertValue(value, calendar), [value, calendar]);\n\n  // We keep track of the placeholder date separately in state so that onChange is not called\n  // until all segments are set. If the value === null (not undefined), then assume the component\n  // is controlled, so use the placeholder as the value until all segments are entered so it doesn't\n  // change from uncontrolled to controlled and emit a warning.\n  let [placeholderDate, setPlaceholderDate] = useState(\n    () => createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n  );\n\n  let val = calendarValue || placeholderDate;\n  let showEra = calendar.identifier === 'gregory' && val.era === 'BC';\n  let formatOpts = useMemo(() => ({\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    timeZone: defaultTimeZone,\n    hideTimeZone,\n    hourCycle: props.hourCycle,\n    showEra,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros\n  }), [props.maxGranularity, granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, hideTimeZone, showEra]);\n  let opts = useMemo(() => getFormatOptions({}, formatOpts), [formatOpts]);\n\n  let dateFormatter = useMemo(() => new DateFormatter(locale, opts), [locale, opts]);\n  let resolvedOptions = useMemo(() => dateFormatter.resolvedOptions(), [dateFormatter]);\n\n  // Determine how many editable segments there are for validation purposes.\n  // The result is cached for performance.\n  let allSegments: Partial<typeof EDITABLE_SEGMENTS> = useMemo(() =>\n    dateFormatter.formatToParts(new Date())\n      .filter(seg => EDITABLE_SEGMENTS[seg.type])\n      .reduce((p, seg) => (p[seg.type] = true, p), {})\n  , [dateFormatter]);\n\n  let [validSegments, setValidSegments] = useState<Partial<typeof EDITABLE_SEGMENTS>>(\n    () => props.value || props.defaultValue ? {...allSegments} : {}\n  );\n\n  let clearedSegment = useRef<string>(undefined);\n\n  // Reset placeholder when calendar changes\n  let lastCalendarIdentifier = useRef(calendar.identifier);\n  useEffect(() => {\n    if (calendar.identifier !== lastCalendarIdentifier.current) {\n      lastCalendarIdentifier.current = calendar.identifier;\n      setPlaceholderDate(placeholder =>\n        Object.keys(validSegments).length > 0\n          ? toCalendar(placeholder, calendar)\n          : createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n      );\n    }\n  }, [calendar, granularity, validSegments, defaultTimeZone, props.placeholderValue]);\n\n  // If there is a value prop, and some segments were previously placeholders, mark them all as valid.\n  if (value && Object.keys(validSegments).length < Object.keys(allSegments).length) {\n    validSegments = {...allSegments};\n    setValidSegments(validSegments);\n  }\n\n  // If the value is set to null and all segments are valid, reset the placeholder.\n  if (value == null && Object.keys(validSegments).length === Object.keys(allSegments).length) {\n    validSegments = {};\n    setValidSegments(validSegments);\n    setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n  }\n\n  // If all segments are valid, use the date from state, otherwise use the placeholder date.\n  let displayValue = calendarValue && Object.keys(validSegments).length >= Object.keys(allSegments).length ? calendarValue : placeholderDate;\n  let setValue = (newValue: DateValue) => {\n    if (props.isDisabled || props.isReadOnly) {\n      return;\n    }\n    let validKeys = Object.keys(validSegments);\n    let allKeys = Object.keys(allSegments);\n\n    // if all the segments are completed or a timefield with everything but am/pm set the time, also ignore when am/pm cleared\n    if (newValue == null) {\n      setDate(null);\n      setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n      setValidSegments({});\n    } else if (validKeys.length >= allKeys.length || (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod && clearedSegment.current !== 'dayPeriod')) {\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, v?.calendar || new GregorianCalendar());\n      setDate(newValue);\n    } else {\n      setPlaceholderDate(newValue);\n    }\n    clearedSegment.current = null;\n  };\n\n  let dateValue = useMemo(() => displayValue.toDate(timeZone), [displayValue, timeZone]);\n  let segments = useMemo(() =>\n    dateFormatter.formatToParts(dateValue)\n      .map(segment => {\n        let isEditable = EDITABLE_SEGMENTS[segment.type];\n        if (segment.type === 'era' && calendar.getEras().length === 1) {\n          isEditable = false;\n        }\n\n        let isPlaceholder = EDITABLE_SEGMENTS[segment.type] && !validSegments[segment.type];\n        let placeholder = EDITABLE_SEGMENTS[segment.type] ? getPlaceholder(segment.type, segment.value, locale) : null;\n        return {\n          type: TYPE_MAPPING[segment.type] || segment.type,\n          text: isPlaceholder ? placeholder : segment.value,\n          ...getSegmentLimits(displayValue, segment.type, resolvedOptions),\n          isPlaceholder,\n          placeholder,\n          isEditable\n        } as DateSegment;\n      })\n  , [dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale]);\n\n  // When the era field appears, mark it valid if the year field is already valid.\n  // If the era field disappears, remove it from the valid segments.\n  if (allSegments.era && validSegments.year && !validSegments.era) {\n    validSegments.era = true;\n    setValidSegments({...validSegments});\n  } else if (!allSegments.era && validSegments.era) {\n    delete validSegments.era;\n    setValidSegments({...validSegments});\n  }\n\n  let markValid = (part: Intl.DateTimeFormatPartTypes) => {\n    validSegments[part] = true;\n    if (part === 'year' && allSegments.era) {\n      validSegments.era = true;\n    }\n    setValidSegments({...validSegments});\n  };\n\n  let adjustSegment = (type: Intl.DateTimeFormatPartTypes, amount: number) => {\n    if (!validSegments[type]) {\n      markValid(type);\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length >= allKeys.length || (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod)) {\n        setValue(displayValue);\n      }\n    } else {\n      setValue(addSegment(displayValue, type, amount, resolvedOptions));\n    }\n  };\n\n  let builtinValidation = useMemo(() => getValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value,\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value: calendarValue,\n    dateValue,\n    calendar,\n    setValue,\n    segments,\n    dateFormatter,\n    validationState,\n    isInvalid: isValueInvalid,\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    isDisabled,\n    isReadOnly,\n    isRequired,\n    increment(part) {\n      adjustSegment(part, 1);\n    },\n    decrement(part) {\n      adjustSegment(part, -1);\n    },\n    incrementPage(part) {\n      adjustSegment(part, PAGE_STEP[part] || 1);\n    },\n    decrementPage(part) {\n      adjustSegment(part, -(PAGE_STEP[part] || 1));\n    },\n    setSegment(part, v) {\n      markValid(part);\n      setValue(setSegment(displayValue, part, v, resolvedOptions));\n    },\n    confirmPlaceholder() {\n      if (props.isDisabled || props.isReadOnly) {\n        return;\n      }\n\n      // Confirm the placeholder if only the day period is not filled in.\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) {\n        validSegments = {...allSegments};\n        setValidSegments(validSegments);\n        setValue(displayValue.copy());\n      }\n    },\n    clearSegment(part) {\n      delete validSegments[part];\n      clearedSegment.current = part;\n      setValidSegments({...validSegments});\n\n      let placeholder = createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone);\n      let value = displayValue;\n\n      // Reset day period to default without changing the hour.\n      if (part === 'dayPeriod' && 'hour' in displayValue && 'hour' in placeholder) {\n        let isPM = displayValue.hour >= 12;\n        let shouldBePM = placeholder.hour >= 12;\n        if (isPM && !shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour - 12});\n        } else if (!isPM && shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour + 12});\n        }\n      } else if (part in displayValue) {\n        value = displayValue.set({[part]: placeholder[part]});\n      }\n\n      setDate(null);\n      setValue(value);\n    },\n    formatValue(fieldOptions: FieldOptions) {\n      if (!calendarValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, formatOpts);\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    },\n    getDateFormatter(locale, formatOptions: FormatterOptions) {\n      let newOptions = {...formatOpts, ...formatOptions};\n      let newFormatOptions = getFormatOptions({}, newOptions);\n      return new DateFormatter(locale, newFormatOptions);\n    }\n  };\n}\n\nfunction getSegmentLimits(date: DateValue, type: string, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (type) {\n    case 'era': {\n      let eras = date.calendar.getEras();\n      return {\n        value: eras.indexOf(date.era),\n        minValue: 0,\n        maxValue: eras.length - 1\n      };\n    }\n    case 'year':\n      return {\n        value: date.year,\n        minValue: 1,\n        maxValue: date.calendar.getYearsInEra(date)\n      };\n    case 'month':\n      return {\n        value: date.month,\n        minValue: getMinimumMonthInYear(date),\n        maxValue: date.calendar.getMonthsInYear(date)\n      };\n    case 'day':\n      return {\n        value: date.day,\n        minValue: getMinimumDayInMonth(date),\n        maxValue: date.calendar.getDaysInMonth(date)\n      };\n  }\n\n  if ('hour' in date) {\n    switch (type) {\n      case 'dayPeriod':\n        return {\n          value: date.hour >= 12 ? 12 : 0,\n          minValue: 0,\n          maxValue: 12\n        };\n      case 'hour':\n        if (options.hour12) {\n          let isPM = date.hour >= 12;\n          return {\n            value: date.hour,\n            minValue: isPM ? 12 : 0,\n            maxValue: isPM ? 23 : 11\n          };\n        }\n\n        return {\n          value: date.hour,\n          minValue: 0,\n          maxValue: 23\n        };\n      case 'minute':\n        return {\n          value: date.minute,\n          minValue: 0,\n          maxValue: 59\n        };\n      case 'second':\n        return {\n          value: date.second,\n          minValue: 0,\n          maxValue: 59\n        };\n    }\n  }\n\n  return {};\n}\n\nfunction addSegment(value: DateValue, part: string, amount: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      return value.cycle(part, amount, {round: part === 'year'});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let isPM = hours >= 12;\n        return value.set({hour: isPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n      case 'minute':\n      case 'second':\n        return value.cycle(part, amount, {\n          round: part !== 'hour',\n          hourCycle: options.hour12 ? 12 : 24\n        });\n    }\n  }\n}\n\nfunction setSegment(value: DateValue, part: string, segmentValue: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'day':\n    case 'month':\n    case 'year':\n    case 'era':\n      return value.set({[part]: segmentValue});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let wasPM = hours >= 12;\n        let isPM = segmentValue >= 12;\n        if (isPM === wasPM) {\n          return value;\n        }\n        return value.set({hour: wasPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n        // In 12 hour time, ensure that AM/PM does not change\n        if (options.hour12) {\n          let hours = value.hour;\n          let wasPM = hours >= 12;\n          if (!wasPM && segmentValue === 12) {\n            segmentValue = 0;\n          }\n          if (wasPM && segmentValue < 12) {\n            segmentValue += 12;\n          }\n        }\n        // fallthrough\n      case 'minute':\n      case 'second':\n        return value.set({[part]: segmentValue});\n    }\n  }\n}\n"],"names":[],"version":3,"file":"useDateFieldState.main.js.map"}