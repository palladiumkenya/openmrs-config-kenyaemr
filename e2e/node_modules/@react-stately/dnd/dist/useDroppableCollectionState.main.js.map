{"mappings":";;;;;;;;AAAA;;;;;;;;;;CAUC;AA2CM,SAAS,0CAA4B,KAAsC;IAChF,IAAI,qBACF,oBAAoB,mBACpB,UAAU,YACV,QAAQ,cACR,UAAU,cACV,UAAU,aACV,SAAS,wBACT,oBAAoB,cACpB,UAAU,oBACV,gBAAgB,eAChB,WAAW,oBACX,gBAAgB,UAChB,MAAM,EACP,GAAG;IACJ,IAAI,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qBAAO,EAAc;IAC/C,IAAI,YAAY,CAAA,GAAA,mBAAK,EAAc;IAEnC,IAAI,oBAAoB,CAAC;QACvB,IAAI,OAAO,YAAY,KAAK,UAAU;YACpC,IAAI,MAAM,WAAW,YAAY,CAAC,OAAO,GAAG;YAC5C,OAAO,OAAO,OAAO;gBAAC,MAAM;qBAAQ;gBAAK,cAAc;YAAO,IAAI;QACpE,OAAO,IAAI,OAAO,YAAY,KAAK,SAAS;YAC1C,IAAI,MAAM,WAAW,WAAW,CAAC,OAAO,GAAG;YAC3C,OAAO,OAAO,OAAO;gBAAC,MAAM;qBAAQ;gBAAK,cAAc;YAAQ,IAAI;QACrE;IACF;IAEA,IAAI,0BAA0B,CAAA,GAAA,wBAAU,EAAE,CAAC;QACzC,IAAI,YACF,OAAO;QAGT,IAAI,UACF,MAAM,SACN,KAAK,qBACL,iBAAiB,cACjB,UAAU,gBACV,YAAY,EACb,GAAG;QAEJ,IAAI,sBAAsB,SAAS,kBAAkB,IAAI,CAAC,CAAA,OAAQ,MAAM,GAAG,CAAC,QAAQ;YAClF,IAAI,gBAAgB,YAAY,OAAO,IAAI,KAAK,UAAU,CAAC,cAAe,CAAA,OAAO,YAAY,KAAK,YAAY,OAAO,YAAY,KAAK,OAAM;YAC5I,IAAI,iBAAiB,aAAa,OAAO,IAAI,KAAK,UAAU,cAAe,CAAA,OAAO,YAAY,KAAK,YAAY,OAAO,YAAY,KAAK,OAAM;YAC7I,mFAAmF;YACnF,IAAI,kBAAkB,cAAc,OAAO,IAAI,KAAK,UAAU,CAAC;YAC/D,+EAA+E;YAC/E,IAAI,oBAAoB,cAAc,OAAO,IAAI,KAAK,UAAU,OAAO,YAAY,KAAK,QAAQ,CAAE,CAAA,cAAc,aAAa,GAAG,CAAC,OAAO,GAAG,CAAA,KAAO,CAAA,CAAC,wBAAwB,qBAAqB,QAAQ,MAAK;YAE7M,IAAI,UAAU,iBAAiB,kBAAkB,mBAAmB,mBAAmB;gBACrF,IAAI,kBACF,OAAO,iBAAiB,QAAQ,OAAO;qBAEvC,OAAO,iBAAiB,CAAC,EAAE;YAE/B;QACF;QAEA,OAAO;IACT,GAAG;QAAC;QAAY;QAAmB;QAAkB;QAAU;QAAY;QAAY;QAAsB;QAAW;KAAO;IAE/H,OAAO;oBACL;0BACA;oBACA;gBACA;QACA,WAAU,SAAS;YACjB,IAAI,IAAI,CAAC,YAAY,CAAC,YACpB;YAGF,IAAI,SAAS,UAAU,OAAO;YAC9B,IAAI,UAAU,OAAO,MAAM,UAAU,KAAK,YACxC,MAAM,UAAU,CAAC;gBACf,MAAM;gBACN,GAAG;gBACH,GAAG;wBACH;YACF;YAGF,IAAI,aAAa,OAAO,gBAAgB,YACtC,YAAY;gBACV,MAAM;gBACN,GAAG;gBACH,GAAG;gBACH,QAAQ;YACV;YAGF,UAAU,OAAO,GAAG;YACpB,UAAU;QACZ;QACA,cAAa,UAAU;YACrB,IAAI,SAAS,UAAU,OAAO;YAC9B,IAAI,wCAAkB,YAAY,SAChC,OAAO;YAGT,6GAA6G;YAC7G,IACE,CAAA,uBAAA,iCAAA,WAAY,IAAI,MAAK,UACrB,CAAA,mBAAA,6BAAA,OAAQ,IAAI,MAAK,UACjB,WAAW,GAAG,KAAK,OAAO,GAAG,IAC7B,WAAW,YAAY,KAAK,OAAO,YAAY,IAC/C,WAAW,YAAY,KAAK,QAC5B,OAAO,YAAY,KAAK,MAExB,OAAO,wCAAkB,kBAAkB,aAAa,WACtD,wCAAkB,YAAY,kBAAkB;YAGpD,OAAO;QACT;QACA,kBAAiB,CAAC;YAChB,OAAO,wBAAwB;QACjC;IACF;AACF;AAEA,SAAS,wCAAkB,CAAa,EAAE,CAAa;IACrD,IAAI,CAAC,GACH,OAAO,CAAC;IAGV,OAAQ,EAAE,IAAI;QACZ,KAAK;YACH,OAAO,CAAA,cAAA,wBAAA,EAAG,IAAI,MAAK;QACrB,KAAK;YACH,OAAO,CAAA,cAAA,wBAAA,EAAG,IAAI,MAAK,UAAU,CAAA,cAAA,wBAAA,EAAG,GAAG,MAAK,EAAE,GAAG,IAAI,CAAA,cAAA,wBAAA,EAAG,YAAY,MAAK,EAAE,YAAY;IACvF;AACF","sources":["packages/@react-stately/dnd/src/useDroppableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DragTypes, DropOperation, DroppableCollectionProps, DropTarget, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCallback, useRef, useState} from 'react';\n\ninterface DropOperationEvent {\n  target: DropTarget,\n  types: DragTypes,\n  allowedOperations: DropOperation[],\n  isInternal: boolean,\n  draggingKeys: Set<Key>\n}\n\nexport interface DroppableCollectionStateOptions extends Omit<DroppableCollectionProps, 'onDropMove' | 'onDropActivate'> {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** Whether the drop events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface DroppableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The current drop target. */\n  target: DropTarget | null,\n  /** Whether drop events are disabled. */\n  isDisabled?: boolean,\n  /** Sets the current drop target. */\n  setTarget(target: DropTarget): void,\n  /** Returns whether the given target is equivalent to the current drop target. */\n  isDropTarget(target: DropTarget): boolean,\n  /** Returns the drop operation for the given parameters. */\n  getDropOperation(e: DropOperationEvent): DropOperation\n}\n\n/**\n * Manages state for a droppable collection.\n */\nexport function useDroppableCollectionState(props: DroppableCollectionStateOptions): DroppableCollectionState  {\n  let {\n    acceptedDragTypes = 'all',\n    isDisabled,\n    onInsert,\n    onRootDrop,\n    onItemDrop,\n    onReorder,\n    shouldAcceptItemDrop,\n    collection,\n    selectionManager,\n    onDropEnter,\n    getDropOperation,\n    onDrop\n  } = props;\n  let [target, setTarget] = useState<DropTarget>(null);\n  let targetRef = useRef<DropTarget>(null);\n\n  let getOppositeTarget = (target: ItemDropTarget): ItemDropTarget => {\n    if (target.dropPosition === 'before') {\n      let key = collection.getKeyBefore(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'after'} : null;\n    } else if (target.dropPosition === 'after') {\n      let key = collection.getKeyAfter(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'before'} : null;\n    }\n  };\n\n  let defaultGetDropOperation = useCallback((e: DropOperationEvent) => {\n    if (isDisabled) {\n      return 'cancel';\n    }\n\n    let {\n      target,\n      types,\n      allowedOperations,\n      isInternal,\n      draggingKeys\n    } = e;\n\n    if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => types.has(type))) {\n      let isValidInsert = onInsert && target.type === 'item' && !isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidReorder = onReorder && target.type === 'item' && isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      // Feedback was that internal root drop was weird so preventing that from happening\n      let isValidRootDrop = onRootDrop && target.type === 'root' && !isInternal;\n      // Automatically prevent items (i.e. folders) from being dropped on themselves.\n      let isValidOnItemDrop = onItemDrop && target.type === 'item' && target.dropPosition === 'on' && !(isInternal && draggingKeys.has(target.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n\n      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) {\n          return getDropOperation(target, types, allowedOperations);\n        } else {\n          return allowedOperations[0];\n        }\n      }\n    }\n\n    return 'cancel';\n  }, [isDisabled, acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onDrop]);\n\n  return {\n    collection,\n    selectionManager,\n    isDisabled,\n    target,\n    setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) {\n        return;\n      }\n\n      let target = targetRef.current;\n      if (target && typeof props.onDropExit === 'function') {\n        props.onDropExit({\n          type: 'dropexit',\n          x: 0, // todo\n          y: 0,\n          target\n        });\n      }\n\n      if (newTarget && typeof onDropEnter === 'function') {\n        onDropEnter({\n          type: 'dropenter',\n          x: 0, // todo\n          y: 0,\n          target: newTarget\n        });\n      }\n\n      targetRef.current = newTarget;\n      setTarget(newTarget);\n    },\n    isDropTarget(dropTarget) {\n      let target = targetRef.current;\n      if (isEqualDropTarget(dropTarget, target)) {\n        return true;\n      }\n\n      // Check if the targets point at the same point between two items, one referring before, and the other after.\n      if (\n        dropTarget?.type === 'item' &&\n        target?.type === 'item' &&\n        dropTarget.key !== target.key &&\n        dropTarget.dropPosition !== target.dropPosition &&\n        dropTarget.dropPosition !== 'on' &&\n        target.dropPosition !== 'on'\n      ) {\n        return isEqualDropTarget(getOppositeTarget(dropTarget), target) ||\n          isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      }\n\n      return false;\n    },\n    getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\n\nfunction isEqualDropTarget(a: DropTarget, b: DropTarget) {\n  if (!a) {\n    return !b;\n  }\n\n  switch (a.type) {\n    case 'root':\n      return b?.type === 'root';\n    case 'item':\n      return b?.type === 'item' && b?.key === a.key && b?.dropPosition === a.dropPosition;\n  }\n}\n"],"names":[],"version":3,"file":"useDroppableCollectionState.main.js.map"}