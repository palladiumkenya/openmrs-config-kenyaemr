{"version":3,"file":"parcel.cjs","sources":["../../src/parcel.js"],"sourcesContent":["/* This import statement requires a peer or dev dependency on react that is fulfilled at runtime.\n * To avoid duplicate bundling of react, we do not do this inside of single-spa-react.js.\n * We also do not set up the prop types in this file to avoid requiring the user of the library\n * to have prop-types installed and in their browser bundle, since not everyone uses prop types.\n */\nimport { SingleSpaContext } from \"single-spa-react\";\nimport * as React from \"react\";\n\nexport default class Parcel extends React.Component {\n  static defaultProps = {\n    wrapWith: \"div\",\n    wrapStyle: {},\n    parcelDidMount: () => {},\n  };\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      hasError: false,\n    };\n\n    if (!props.config) {\n      throw new Error(\n        `single-spa-react's Parcel component requires the 'config' prop to either be a parcel config or a loading function that returns a promise. See https://github.com/single-spa/single-spa-react`\n      );\n    }\n  }\n  componentDidMount() {\n    this.unmounted = false;\n    this.addThingToDo(\"mount\", () => {\n      const mountParcel = this.props.mountParcel || this.mountParcel;\n      if (!mountParcel) {\n        throw new Error(`\n\t\t\t\t  <Parcel /> was not passed a mountParcel prop, nor is it rendered where mountParcel is within the React context.\n\t\t\t\t  If you are using <Parcel /> within a module that is not a single-spa application, you will need to import mountRootParcel from single-spa and pass it into <Parcel /> as a mountParcel prop\t\n\t\t\t\t`);\n      }\n      let domElement;\n      if (this.el) {\n        domElement = this.el;\n      } else {\n        this.createdDomElement = domElement = document.createElement(\n          this.props.wrapWith\n        );\n        Object.keys(this.props.wrapStyle).forEach((key) => {\n          domElement.style[key] = this.props.wrapStyle[key];\n        });\n        this.props.appendTo.appendChild(domElement);\n      }\n      this.parcel = mountParcel(this.props.config, {\n        domElement,\n        ...this.getParcelProps(),\n      });\n      this.parcel.mountPromise.then(this.props.parcelDidMount);\n      return this.parcel.mountPromise;\n    });\n  }\n  componentDidUpdate() {\n    this.addThingToDo(\"update\", () => {\n      if (this.parcel && this.parcel.update) {\n        return this.parcel.update(this.getParcelProps());\n      }\n    });\n  }\n  componentWillUnmount() {\n    this.addThingToDo(\"unmount\", () => {\n      if (this.parcel && this.parcel.getStatus() === \"MOUNTED\") {\n        return this.parcel.unmount();\n      }\n    });\n\n    if (this.createdDomElement) {\n      this.createdDomElement.parentNode.removeChild(this.createdDomElement);\n    }\n\n    this.unmounted = true;\n  }\n  render() {\n    if (this.props.appendTo) {\n      if (SingleSpaContext && SingleSpaContext.Consumer) {\n        return (\n          <SingleSpaContext.Consumer>\n            {(context) => {\n              this.mountParcel = context ? context.mountParcel : null;\n\n              return null;\n            }}\n          </SingleSpaContext.Consumer>\n        );\n      } else {\n        return null;\n      }\n    } else {\n      const children =\n        SingleSpaContext && SingleSpaContext.Consumer ? (\n          <SingleSpaContext.Consumer>\n            {(context) => {\n              this.mountParcel = context ? context.mountParcel : null;\n\n              return null;\n            }}\n          </SingleSpaContext.Consumer>\n        ) : undefined;\n\n      return React.createElement(\n        this.props.wrapWith,\n        {\n          ref: this.handleRef,\n          style: this.props.wrapStyle,\n          className: this.props.wrapClassName,\n        },\n        children\n      );\n    }\n  }\n  handleRef = (el) => {\n    this.el = el;\n  };\n  addThingToDo = (action, thing) => {\n    if (this.state.hasError && action !== \"unmount\") {\n      // In an error state, we don't do anything anymore except for unmounting\n      return;\n    }\n\n    this.nextThingToDo = (this.nextThingToDo || Promise.resolve())\n      .then((...args) => {\n        if (this.unmounted && action !== \"unmount\") {\n          // Never do anything once the react component unmounts\n          return;\n        }\n\n        return thing(...args);\n      })\n      .catch((err) => {\n        this.nextThingToDo = Promise.resolve(); // reset so we don't .then() the bad promise again\n        this.setState({ hasError: true });\n\n        if (err && err.message) {\n          err.message = `During '${action}', parcel threw an error: ${err.message}`;\n        }\n\n        if (this.props.handleError) {\n          this.props.handleError(err);\n        } else {\n          setTimeout(() => {\n            throw err;\n          });\n        }\n\n        // No more things to do should be done -- the parcel is in an error state\n        throw err;\n      });\n  };\n  getParcelProps = () => {\n    // Make sure domElement is a prop, so that the parcel updates the correct domEl rather than creating a new one\n    const parcelProps = { ...this.props, domElement: this.el };\n\n    delete parcelProps.mountParcel;\n    delete parcelProps.config;\n    delete parcelProps.wrapWith;\n    delete parcelProps.wrapStyle;\n    delete parcelProps.appendTo;\n    delete parcelProps.handleError;\n    delete parcelProps.parcelDidMount;\n\n    return parcelProps;\n  };\n}\n"],"names":["Parcel","props","el","action","thing","_this","state","hasError","nextThingToDo","Promise","resolve","then","unmounted","catch","err","setState","message","handleError","setTimeout","parcelProps","domElement","mountParcel","config","wrapWith","wrapStyle","appendTo","parcelDidMount","Error","addThingToDo","_this2","createdDomElement","document","createElement","Object","keys","forEach","key","style","appendChild","parcel","getParcelProps","mountPromise","_this3","update","_this4","getStatus","unmount","this","parentNode","removeChild","SingleSpaContext","Consumer","React","context","_this5","children","undefined","ref","handleRef","className","wrapClassName","Component"],"mappings":"07DAQqBA,+RAMPC,mIACJA,iBAoGI,SAACC,KACNA,GAAKA,4BAEG,SAACC,EAAQC,GAClBC,EAAKC,MAAMC,UAAuB,YAAXJ,MAKtBK,eAAiBH,EAAKG,eAAiBC,QAAQC,WACjDC,MAAK,eACAN,EAAKO,WAAwB,YAAXT,SAKfC,6BAERS,OAAM,SAACC,WACDN,cAAgBC,QAAQC,YACxBK,SAAS,CAAER,UAAU,IAEtBO,GAAOA,EAAIE,UACbF,EAAIE,0BAAqBb,uCAAmCW,EAAIE,UAG9DX,EAAKJ,MAAMgB,cACRhB,MAAMgB,YAAYH,GAEvBI,YAAW,iBACHJ,KAKJA,kCAGK,eAETK,SAAmBd,EAAKJ,WAAOmB,WAAYf,EAAKH,mBAE/CiB,EAAYE,mBACZF,EAAYG,cACZH,EAAYI,gBACZJ,EAAYK,iBACZL,EAAYM,gBACZN,EAAYF,mBACZE,EAAYO,eAEZP,OApJFb,MAAQ,CACXC,UAAU,IAGPN,EAAMqB,aACH,IAAIK,6PAKd,2BACOf,WAAY,OACZgB,aAAa,SAAS,eAQrBR,EAPEC,EAAcQ,EAAK5B,MAAMoB,aAAeQ,EAAKR,gBAC9CA,QACG,IAAIM,+VAMRE,EAAK3B,GACPkB,EAAaS,EAAK3B,IAElB2B,EAAKC,kBAAoBV,EAAaW,SAASC,cAC7CH,EAAK5B,MAAMsB,UAEbU,OAAOC,KAAKL,EAAK5B,MAAMuB,WAAWW,SAAQ,SAACC,GACzChB,EAAWiB,MAAMD,GAAOP,EAAK5B,MAAMuB,UAAUY,MAE/CP,EAAK5B,MAAMwB,SAASa,YAAYlB,IAElCS,EAAKU,OAASlB,EAAYQ,EAAK5B,MAAMqB,UACnCF,WAAAA,GACGS,EAAKW,mBAEVX,EAAKU,OAAOE,aAAa9B,KAAKkB,EAAK5B,MAAMyB,gBAClCG,EAAKU,OAAOE,kDAGvB,2BACOb,aAAa,UAAU,cACtBc,EAAKH,QAAUG,EAAKH,OAAOI,cACtBD,EAAKH,OAAOI,OAAOD,EAAKF,yDAIrC,2BACOZ,aAAa,WAAW,cACvBgB,EAAKL,QAAsC,YAA5BK,EAAKL,OAAOM,mBACtBD,EAAKL,OAAOO,aAInBC,KAAKjB,wBACFA,kBAAkBkB,WAAWC,YAAYF,KAAKjB,wBAGhDlB,WAAY,wBAEnB,yBACMmC,KAAK9C,MAAMwB,gBACTyB,GAAoBA,EAAiBC,SAErCC,gBAACF,EAAiBC,eACf,SAACE,UACAC,EAAKjC,YAAcgC,EAAUA,EAAQhC,YAAc,KAE5C,QAKN,SAGHkC,EACJL,GAAoBA,EAAiBC,SACnCC,gBAACF,EAAiBC,eACf,SAACE,UACAC,EAAKjC,YAAcgC,EAAUA,EAAQhC,YAAc,KAE5C,aAGTmC,SAECJ,EAAMpB,cACXe,KAAK9C,MAAMsB,SACX,CACEkC,IAAKV,KAAKW,UACVrB,MAAOU,KAAK9C,MAAMuB,UAClBmC,UAAWZ,KAAK9C,MAAM2D,eAExBL,sCAvG4BH,EAAMS,cAArB7D,iBACG,CACpBuB,SAAU,MACVC,UAAW,GACXE,eAAgB"}