import { t as Y, g as l, m as a, o as r, c as J, a as V } from "./color-scale-utils-f3PWy_Op.mjs";
import { T as yt, e as Dt, f as Lt, h as Ft, j as Pt, l as Mt, n as kt, p as Bt, q as It, r as Ht, I as Gt, d as Vt, s as Nt, J as Ut, K as Zt, L as _t, M as zt, N as Wt, u as jt, v as $t, O as Kt, w as Jt, x as qt, y as Xt, z as Qt, A as Yt, B as eo, C as so, D as to, G as oo, E as no, F as io, H as ro } from "./color-scale-utils-f3PWy_Op.mjs";
import { i as ho } from "./index-DwV8lNnO.mjs";
import { ChartModel as Re, ChartModelCartesian as Te, AlluvialChartModel as be, BoxplotChartModel as Oe, BulletChartModel as Se, ChoroplethModel as fe, CirclePackChartModel as Ae, PieChartModel as xe, GaugeChartModel as ye, HeatmapModel as De, ChartModelBinned as Le, MeterChartModel as Fe, RadarChartModel as Pe, TreeChartModel as Me, TreemapChartModel as ke, WordCloudModel as Be } from "./model/index.mjs";
import { $ as j, r as i, q as h, L as Z, y as A, t as N, e as $, S as Ie, u as K, F as p, l as R } from "./axis-scales-CPuwbFQf.mjs";
import { A as mo, a as lo, b as po, c as Co, d as uo, f as vo, B as go, g as wo, C as Eo, h as Ro, i as To, j as bo, k as Oo, m as So, n as fo, D as Ao, o as xo, G as yo, p as Do, s as Lo, v as Fo, M as Po, w as Mo, P as ko, x as Bo, R as Io, z as Ho, H as Go, T as Vo, I as No, J as Uo, K as Zo, N as _o, O as zo, Q as Wo, U as jo, V as $o, W as Ko, X as Jo, Z as qo, Y as Xo, _ as Qo } from "./axis-scales-CPuwbFQf.mjs";
import { c as He, L as ee, C as Ge, T as _, a as z, b as g, S as L, d as se, M as W, e as Ve, f as Ne, g as Ue, H as Ze, Z as _e, A as te, h as ze, i as d, G as w, R as B, j as k, k as oe, l as M, m as C, B as We, n as I, o as je, p as $e, q as ne, r as Ke, s as Je, t as ie, u as re, v as U, w as ae, x as he, y as ce, P as qe, D as Xe, z as Qe, E as Ye, F as es, I as ss, J as ts, K as os, N as ns, O as is, Q as rs, U as as, V as hs, W as cs } from "./choropleth-0DsmaWsP.mjs";
import { X as en, a8 as sn, a9 as tn, a7 as on, Y as nn, _ as rn, $ as an, a0 as hn, a1 as cn, a2 as mn, a3 as ln, a4 as pn, a5 as dn, a6 as Cn } from "./choropleth-0DsmaWsP.mjs";
import { b as ms, C as ls, E as ps, F as ds, T as Cs, a as us, c as vs, Z as gs, f as ws } from "./index-DFubnvsv.mjs";
import { D as Es, G as Rs } from "./angle-utils-CGNI01fr.mjs";
import { S as vn, d as gn, a as wn, p as En, b as Rn, r as Tn } from "./angle-utils-CGNI01fr.mjs";
function Ts(t, s, e) {
  var n = t.length;
  return e = e === void 0 ? n : e, !s && e >= n ? t : ms(t, s, e);
}
var bs = "\\ud800-\\udfff", Os = "\\u0300-\\u036f", Ss = "\\ufe20-\\ufe2f", fs = "\\u20d0-\\u20ff", As = Os + Ss + fs, xs = "\\ufe0e\\ufe0f", ys = "\\u200d", Ds = RegExp("[" + ys + bs + As + xs + "]");
function me(t) {
  return Ds.test(t);
}
function Ls(t) {
  return t.split("");
}
var le = "\\ud800-\\udfff", Fs = "\\u0300-\\u036f", Ps = "\\ufe20-\\ufe2f", Ms = "\\u20d0-\\u20ff", ks = Fs + Ps + Ms, Bs = "\\ufe0e\\ufe0f", Is = "[" + le + "]", q = "[" + ks + "]", X = "\\ud83c[\\udffb-\\udfff]", Hs = "(?:" + q + "|" + X + ")", pe = "[^" + le + "]", de = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ce = "[\\ud800-\\udbff][\\udc00-\\udfff]", Gs = "\\u200d", ue = Hs + "?", ve = "[" + Bs + "]?", Vs = "(?:" + Gs + "(?:" + [pe, de, Ce].join("|") + ")" + ve + ue + ")*", Ns = ve + ue + Vs, Us = "(?:" + [pe + q + "?", q, de, Ce, Is].join("|") + ")", Zs = RegExp(X + "(?=" + X + ")|" + Us + Ns, "g");
function _s(t) {
  return t.match(Zs) || [];
}
function zs(t) {
  return me(t) ? _s(t) : Ls(t);
}
function Ws(t) {
  return function(s) {
    s = Y(s);
    var e = me(s) ? zs(s) : void 0, n = e ? e[0] : s.charAt(0), o = e ? Ts(e, 1).join("") : s.slice(1);
    return n[t]() + o;
  };
}
var js = Ws("toUpperCase");
function $s(t) {
  return js(Y(t).toLowerCase());
}
var Ks = He(function(t, s, e) {
  return s = s.toLowerCase(), t + (e ? $s(s) : s);
});
class T {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(s, e) {
    this.components = [], this.services = {
      canvasZoom: ls,
      domUtils: Es,
      events: ps,
      files: ds,
      gradientUtils: Rs,
      transitions: Cs
    }, this.model = new Re(this.services);
  }
  // Contains the code that uses properties that are overridable by the super-class
  init(s, e) {
    this.model.set({ holder: s }, { skipUpdate: !0 }), Object.keys(this.services).forEach((n) => {
      const o = this.services[n];
      this.services[n] = new o(this.model, this.services);
    }), this.services.events.addEventListener(j.Model.UPDATE, (n) => {
      const o = !!l(n, "detail", "animate");
      this.update(o);
    }), this.model.setData(e.data), this.services.events.addEventListener(j.Chart.RESIZE, () => {
      this.update(!1);
    }), this.components = this.getComponents(), this.update();
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    return console.error("getComponents() method is not implemented"), [];
  }
  update(s = !0) {
    if (!this.components)
      return;
    Object.keys(this.services).forEach((o) => {
      this.services[o].update();
    }), this.components.forEach((o) => o.render(s));
    const e = this.services.transitions.getPendingTransitions(), n = Object.keys(e).map((o) => e[o].end().catch((m) => m));
    Promise.all(n).then(
      () => this.services.events.dispatchEvent(j.Chart.RENDER_FINISHED)
    );
  }
  destroy() {
    this.components.forEach((s) => s.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });
  }
  getChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "toolbar", "enabled"), c = {
      id: "legend",
      components: [new ee(this.model, this.services)],
      growth: i.PREFERRED
    }, m = l(n, "canvasZoom", "enabled");
    m && m === !0 && s.push(new Ge(this.model, this.services));
    const b = !!this.model.getOptions().title, O = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, x = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, F = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            O,
            ...o ? [x] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, y = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: l(e, "graphFrameRenderType") || A.SVG
    }, D = l(e, "excludeLegend") !== !0 && n.legend.enabled !== !1;
    let S = h.COLUMN;
    if (D) {
      const f = l(n, "legend", "position");
      f === "left" ? (S = h.ROW, n.legend.orientation || (n.legend.orientation = N.VERTICAL)) : f === "right" ? (S = h.ROW_REVERSE, n.legend.orientation || (n.legend.orientation = N.VERTICAL)) : f === "bottom" && (S = h.COLUMN_REVERSE);
    }
    const P = {
      id: "spacer",
      components: [new L(this.model, this.services)],
      growth: i.PREFERRED
    }, v = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...D ? [c] : [],
            ...D ? [P] : [],
            y
          ],
          {
            direction: S
          }
        )
      ],
      growth: i.STRETCH
    }, E = [];
    if (b || o) {
      E.push(F);
      const f = {
        id: "spacer",
        components: [
          new L(this.model, this.services, o ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      E.push(f);
    }
    return E.push(v), [
      new se(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, E, {
        direction: h.COLUMN
      })
    ];
  }
}
class u extends T {
  constructor(s, e) {
    super(s, e), this.services = Object.assign(this.services, {
      cartesianScales: us,
      curves: vs,
      zoom: gs
    }), this.model = new Te(this.services);
  }
  getAxisChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "zoomBar", $.TOP, "enabled"), c = l(n, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const m = this.services.cartesianScales.getMainXAxisPosition(), b = l(n, "axes", m, "scaleType"), O = o && m === $.BOTTOM && b === Ie.TIME, x = this.services.zoom.isZoomBarLocked($.TOP), F = !!this.model.getOptions().title, y = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, D = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, S = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            y,
            ...c ? [D] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, P = {
      id: "legend",
      components: [new ee(this.model, this.services)],
      growth: i.PREFERRED
    };
    O && !x && s.push(
      new Ve(this.model, this.services),
      new Ne(this.model, this.services)
    ), s.push(new Ue(this.model, this.services)), s.push(new Ze(this.model, this.services));
    const v = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: A.SVG
    }, E = l(e, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;
    let f = h.COLUMN;
    if (E) {
      const G = l(this.model.getOptions(), "legend", "position");
      G === K.LEFT ? (f = h.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = N.VERTICAL)) : G === K.RIGHT ? (f = h.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = N.VERTICAL)) : G === K.BOTTOM && (f = h.COLUMN_REVERSE);
    }
    const ge = {
      id: "spacer",
      components: [new L(this.model, this.services)],
      growth: i.PREFERRED
    }, we = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...E ? [P] : [],
            ...E ? [ge] : [],
            v
          ],
          {
            direction: f
          }
        )
      ],
      growth: i.STRETCH
    }, Ee = {
      id: "zoom-bar",
      components: [new _e(this.model, this.services)],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, H = [];
    if (F || c) {
      H.push(S);
      const G = {
        id: "spacer",
        components: [
          new L(this.model, this.services, c ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      H.push(G);
    }
    return O && H.push(Ee), H.push(we), [
      new te(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, H, {
        direction: h.COLUMN
      })
    ];
  }
}
class tt extends T {
  constructor(s, e) {
    super(s, e), this.model = new be(this.services), this.model.setOptions(a(r.alluvialChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new ze(this.model, this.services)];
    return this.getChartComponents(s, {
      excludeLegend: !0
    });
  }
}
class ot extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(
      a(J(r.areaChart), e.options)
    ), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new k(this.model, this.services),
      new oe(this.model, this.services),
      new M(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0
      }),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class nt extends u {
  constructor(s, e) {
    super(s, e), this.model = new Oe(this.services), this.model.setOptions(a(r.boxplotChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new We(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(s, {
      legend: {
        enabled: !1
      }
    });
  }
}
class it extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.bubbleChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new je(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class rt extends u {
  constructor(s, e) {
    super(s, e), this.model = new Se(this.services), this.model.setOptions(a(r.bulletChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new $e(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class at extends T {
  constructor(s, e) {
    super(s, e), this.model = new fe(this.services), this.model.setOptions(
      a(r.choroplethChart, e.options)
    ), this.init(s, e);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "toolbar", "enabled"), c = !!this.model.getOptions().title, m = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, b = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, O = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            m,
            ...o ? [b] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, x = {
      id: "legend",
      components: [
        new ne(this.model, this.services, {
          chartType: "choropleth"
        })
      ],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, F = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: A.SVG
    }, y = l(e, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, D = h.COLUMN_REVERSE, S = {
      id: "spacer",
      components: [new L(this.model, this.services, { size: 15 })],
      growth: i.PREFERRED
    }, P = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...y ? [x] : [],
            ...y ? [S] : [],
            F
          ],
          {
            direction: D
          }
        )
      ],
      growth: i.STRETCH
    }, v = [];
    if (c || o) {
      v.push(O);
      const E = {
        id: "spacer",
        components: [
          new L(this.model, this.services, o ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      v.push(E);
    }
    return v.push(P), [
      new se(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, v, {
        direction: h.COLUMN
      })
    ];
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new Ke(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class ht extends T {
  constructor(s, e) {
    super(s, e), this.model = new Ae(this.services), this.model.setOptions(a(r.circlePackChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new Je(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
const Q = {
  [R.LINE]: [k, M],
  [R.SCATTER]: [M],
  [R.AREA]: [oe, k, M],
  [R.STACKED_AREA]: [ie, k, re, U],
  [R.SIMPLE_BAR]: [ae],
  [R.GROUPED_BAR]: [he, I],
  [R.STACKED_BAR]: [ce, U]
};
class ct extends u {
  constructor(s, e) {
    super(s, e);
    const n = a(r.comboChart, e.options);
    e.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), n.comboChartTypes = [{ type: R.LINE, correspondingDatasets: [] }]), this.model.setOptions(n), this.init(s, e);
  }
  getGraphComponents() {
    const { comboChartTypes: s } = this.model.getOptions();
    let e = 0;
    const n = s.map((o) => {
      const c = o.type;
      let m;
      if (typeof o.type == "string") {
        if (!Object.keys(Q).includes(o.type))
          return console.error(
            `Invalid chart type "${o.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`
          ), null;
        let b = !1;
        const O = `${Ks(o.type)}Chart`;
        return m = V({}, r[O], this.model.getOptions(), o.options), o.type === R.STACKED_AREA && (b = !0), Q[o.type].map(
          (x) => new x(this.model, this.services, {
            groups: o.correspondingDatasets,
            id: e++,
            options: m,
            stacked: b
          })
        );
      } else
        return m = V({}, this.model.getOptions(), o.options), new c(this.model, this.services, {
          groups: o.correspondingDatasets,
          id: e++,
          options: m
        });
    }).filter((o) => o !== null);
    return ws(n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const { comboChartTypes: s } = this.model.getOptions(), e = s.some(
      (c) => c.type === R.STACKED_BAR || c.type === R.STACKED_AREA
    ), n = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      }),
      ...e ? [] : [new B(this.model, this.services)],
      ...this.getGraphComponents()
    ];
    return this.getAxisChartComponents(n);
  }
}
class Js extends T {
  // TODO - Optimize the use of "extending"
  constructor(s, e, n = !1) {
    super(s, e), this.model = new xe(this.services), !n && (this.model.setOptions(a(r.pieChart, e.options)), this.init(s, e));
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new qe(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.PIE
      })
    ];
    return this.getChartComponents(s);
  }
}
class mt extends Js {
  constructor(s, e) {
    super(s, e, !0), this.model.setOptions(a(r.donutChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new Xe(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.DONUT
      })
    ];
    return this.getChartComponents(s);
  }
}
class lt extends T {
  constructor(s, e) {
    super(s, e), this.model = new ye(this.services), this.model.setOptions(a(r.gaugeChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new Qe(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class pt extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.groupedBarChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new he(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class dt extends u {
  constructor(s, e) {
    super(s, e), this.model = new De(this.services), this.model.setOptions(
      a(r.heatmapChart, e.options)
    ), this.init(s, e);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getAxisChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const c = !!this.model.getOptions().title, m = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, b = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, O = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            m,
            ...o ? [b] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, x = {
      id: "legend",
      components: [
        new ne(this.model, this.services, {
          chartType: "heatmap"
        })
      ],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, F = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: A.SVG
    }, y = l(e, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, D = h.COLUMN_REVERSE, S = {
      id: "spacer",
      components: [new L(this.model, this.services, { size: 15 })],
      growth: i.PREFERRED
    }, P = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...y ? [x] : [],
            ...y ? [S] : [],
            F
          ],
          {
            direction: D
          }
        )
      ],
      growth: i.STRETCH
    }, v = [];
    if (c || o) {
      v.push(O);
      const E = {
        id: "spacer",
        components: [
          new L(this.model, this.services, o ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      v.push(E);
    }
    return v.push(P), [
      new te(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, v, {
        direction: h.COLUMN
      })
    ];
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new Ye(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class Ct extends u {
  constructor(s, e) {
    super(s, e), this.model = new Le(this.services), this.model.setOptions(a(r.histogramChart, e.options)), this.init(s, e), this.update();
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new es(this.model, this.services),
      new ss(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class ut extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.lineChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new k(this.model, this.services),
      new M(this.model, this.services, { handleThresholds: !0 }),
      new ts(this.model, this.services),
      new I(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class vt extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.lollipopChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new os(this.model, this.services),
      new M(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class gt extends T {
  constructor(s, e) {
    var o;
    super(s, e), this.model = new Fe(this.services);
    const n = (o = e.options.meter) != null && o.proportional ? V(J(r.proportionalMeterChart), e.options) : V(J(r.meterChart), e.options);
    this.model.setOptions(n), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const e = [
      ...l(this.model.getOptions(), "meter", "showLabels") ? [
        // Meter has a unique dataset title within the graph
        {
          id: "meter-title",
          components: [new ns(this.model, this.services)],
          growth: i.STRETCH,
          renderType: A.SVG
        },
        // Create the title spacer
        {
          id: "spacer",
          components: [
            new L(this.model, this.services, {
              size: 8
            })
          ],
          growth: i.STRETCH
        }
      ] : [],
      // Specify what to render inside the graph only
      {
        id: "meter-graph",
        components: [new is(this.model, this.services)],
        growth: i.STRETCH,
        renderType: A.SVG
      }
    ], n = [
      new g(this.model, this.services, e, {
        direction: h.COLUMN
      })
    ];
    return this.getChartComponents(n, {
      graphFrameRenderType: A.HTML
    });
  }
}
class wt extends T {
  constructor(s, e) {
    super(s, e), this.model = new Pe(this.services), this.model.setOptions(a(r.radarChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new rs(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class Et extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.scatterChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new M(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class Rt extends T {
  constructor(s, e) {
    super(s, e), this.model = new Me(this.services), this.model.setOptions(a(r.treeChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new as(this.model, this.services)];
    return this.getChartComponents(s, {
      excludeLegend: !0
    });
  }
}
class Tt extends T {
  constructor(s, e) {
    super(s, e), this.model = new ke(this.services), this.model.setOptions(a(r.treemapChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [new hs(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class bt extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.simpleBarChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new ae(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class Ot extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.stackedAreaChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new U(this.model, this.services),
      new ie(this.model, this.services),
      new k(this.model, this.services, { stacked: !0 }),
      new re(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0,
        stacked: !0
      }),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class St extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.stackedBarChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new U(this.model, this.services),
      new ce(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      }),
      new I(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class ft extends T {
  constructor(s, e) {
    super(s, e), this.model = new Be(this.services), this.model.setOptions(a(r.wordCloudChart, e.options)), this.init(s, e);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const s = [
      new cs(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.PIE
      })
    ];
    return this.getChartComponents(s);
  }
}
export {
  mo as Alignments,
  ze as Alluvial,
  tt as AlluvialChart,
  be as AlluvialChartModel,
  oe as Area,
  ot as AreaChart,
  lo as AreaEvent,
  po as ArrowDirections,
  en as Axis,
  u as AxisChart,
  te as AxisChartsTooltip,
  Co as AxisEvent,
  uo as AxisFlavor,
  $ as AxisPositions,
  vo as AxisTitleOrientations,
  sn as Bar,
  go as BarEvent,
  es as BinnedRuler,
  We as Boxplot,
  nt as BoxplotChart,
  Oe as BoxplotChartModel,
  wo as BoxplotEvent,
  je as Bubble,
  it as BubbleChart,
  $e as Bullet,
  rt as BulletChart,
  Se as BulletChartModel,
  Eo as CalloutDirections,
  Ge as CanvasChartClip,
  ls as CanvasZoom,
  Ro as CanvasZoomEvent,
  To as CartesianOrientations,
  us as CartesianScales,
  T as Chart,
  Ne as ChartBrush,
  Ve as ChartClip,
  bo as ChartEvent,
  Re as ChartModel,
  Le as ChartModelBinned,
  Te as ChartModelCartesian,
  Oo as ChartTheme,
  R as ChartTypes,
  Ke as Choropleth,
  at as ChoroplethChart,
  fe as ChoroplethModel,
  Je as CirclePack,
  ht as CirclePackChart,
  Ae as CirclePackChartModel,
  So as ColorClassNameTypes,
  fo as ColorLegendType,
  ne as ColorScaleLegend,
  ct as ComboChart,
  tn as Component,
  vs as Curves,
  Es as DOMUtils,
  Ao as DividerStatus,
  xo as DominantBaseline,
  Xe as Donut,
  mt as DonutChart,
  ps as Events,
  at as ExperimentalChoroplethChart,
  ds as Files,
  Qe as Gauge,
  lt as GaugeChart,
  ye as GaugeChartModel,
  yo as GaugeEvent,
  Do as GaugeTypes,
  on as GeoProjection,
  Rs as GradientUtils,
  w as Grid,
  he as GroupedBar,
  pt as GroupedBarChart,
  Ye as Heatmap,
  dt as HeatmapChart,
  De as HeatmapModel,
  Ze as Highlight,
  ss as Histogram,
  Ct as HistogramChart,
  nn as HoverAxis,
  Z as LayoutAlignItems,
  g as LayoutComponent,
  h as LayoutDirection,
  i as LayoutGrowth,
  ee as Legend,
  Lo as LegendItemType,
  N as LegendOrientations,
  K as LegendPositions,
  k as Line,
  ut as LineChart,
  Fo as LineEvent,
  os as Lollipop,
  vt as LollipopChart,
  is as Meter,
  gt as MeterChart,
  Fe as MeterChartModel,
  ns as MeterTitle,
  W as Modal,
  Po as ModalEvent,
  Mo as ModelEvent,
  qe as Pie,
  Js as PieChart,
  xe as PieChartModel,
  ko as PieEvent,
  Bo as Projection,
  rs as Radar,
  wt as RadarChart,
  Pe as RadarChartModel,
  Io as RadarEvent,
  A as RenderTypes,
  B as Ruler,
  Ie as ScaleTypes,
  M as Scatter,
  Et as ScatterChart,
  Ho as ScatterEvent,
  vn as Service,
  ae as SimpleBar,
  bt as SimpleBarChart,
  C as Skeleton,
  ts as SkeletonLines,
  p as Skeletons,
  L as Spacer,
  ie as StackedArea,
  Ot as StackedAreaChart,
  ce as StackedBar,
  St as StackedBarChart,
  U as StackedRuler,
  re as StackedScatter,
  Go as Statuses,
  yt as TIME_INTERVALS,
  Vo as TextAnchor,
  Ue as Threshold,
  No as ThresholdEvent,
  Uo as TickRotations,
  Zo as TimeIntervalNames,
  _ as Title,
  z as Toolbar,
  _o as ToolbarControlTypes,
  se as Tooltip,
  zo as TooltipEvent,
  Cs as Transitions,
  as as Tree,
  Rt as TreeChart,
  Me as TreeChartModel,
  Wo as TreeEvent,
  jo as TreeTypes,
  hs as Treemap,
  Tt as TreemapChart,
  ke as TreemapChartModel,
  $o as TreemapEvent,
  Ko as TruncationTypes,
  d as TwoDimensionalAxes,
  cs as WordCloud,
  ft as WordCloudChart,
  Jo as WordCloudEvent,
  Be as WordCloudModel,
  I as ZeroLine,
  gs as Zoom,
  _e as ZoomBar,
  qo as ZoomBarTypes,
  Xo as ZoomDomainEvent,
  Qo as ZoombarEvent,
  Dt as alluvial,
  Lt as area,
  rn as arrowLeft,
  an as arrowRight,
  Ft as axis,
  Pt as baseTooltip,
  Mt as boxplot,
  hn as buildBezierPathString,
  cn as buildElbowPathString,
  mn as buildStraightPathString,
  kt as canvasZoomSettings,
  Bt as carbonPrefix,
  ln as circle,
  It as circlePack,
  Ht as color,
  Gt as computeTimeIntervalName,
  Vt as configurations,
  Nt as defaultLegendAdditionalItems,
  gn as degToRad,
  pn as diamond,
  wn as distanceBetweenPointOnCircAndVerticalDiameter,
  Ut as formatDateTillMilliSeconds,
  Zt as formatTick,
  _t as getColorScale,
  zt as getDomain,
  Wt as getTimeformats,
  jt as grid,
  $t as histogram,
  ho as interfaces,
  Kt as isTickPrimary,
  Jt as legend,
  qt as lines,
  Xt as meter,
  r as options,
  Qt as pie,
  En as polarToCartesianCoords,
  Rn as radToDeg,
  Yt as radar,
  Tn as radialLabelPlacement,
  eo as ruler,
  so as spacers,
  dn as square,
  Cn as tee,
  to as timeScale,
  oo as toolbar,
  no as tooltips,
  io as transitions,
  ro as zoomBar
};
//# sourceMappingURL=index.mjs.map
