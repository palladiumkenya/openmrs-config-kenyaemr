{"mappings":"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","sources":["packages/react-aria-components/src/Tree.tsx"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaTreeGridListProps, useTreeGridList, useTreeGridListItem} from '@react-aria/tree';\nimport {ButtonContext} from './Button';\nimport {CheckboxContext} from './RSPContexts';\nimport {Collection, CollectionBuilder, CollectionNode, createBranchComponent, createLeafComponent, useCachedChildren} from '@react-aria/collections';\nimport {CollectionProps, CollectionRendererContext, DefaultCollectionRenderer, ItemRenderProps, usePersistedKeys} from './Collection';\nimport {ContextValue, DEFAULT_SLOT, Provider, RenderProps, ScrollableProps, SlotProps, StyleRenderProps, useContextProps, useRenderProps} from './utils';\nimport {DisabledBehavior, Expandable, forwardRefType, HoverEvents, Key, LinkDOMProps, RefObject} from '@react-types/shared';\nimport {filterDOMProps, useObjectRef} from '@react-aria/utils';\nimport {FocusScope,  mergeProps, useFocusRing, useGridListSelectionCheckbox, useHover} from 'react-aria';\nimport {Collection as ICollection, Node, SelectionBehavior, TreeState, useTreeState} from 'react-stately';\nimport React, {createContext, ForwardedRef, forwardRef, HTMLAttributes, ReactNode, useContext, useEffect, useMemo, useRef} from 'react';\nimport {useControlledState} from '@react-stately/utils';\n\nclass TreeCollection<T> implements ICollection<Node<T>> {\n  private flattenedRows: Node<T>[];\n  private keyMap: Map<Key, CollectionNode<T>> = new Map();\n\n  constructor(opts) {\n    let {collection, expandedKeys} = opts;\n    let {flattenedRows, keyMap} = flattenTree<T>(collection, {expandedKeys});\n    this.flattenedRows = flattenedRows;\n    // Use generated keyMap because it contains the modified collection nodes (aka it adjusts the indexes so that they ignore the existence of the Content items)\n    this.keyMap = keyMap;\n  }\n\n  // TODO: should this collection's getters reflect the flattened structure or the original structure\n  // If we respresent the flattened structure, it is easier for the keyboard nav but harder to find all the nodes\n  *[Symbol.iterator]() {\n    yield* this.flattenedRows;\n  }\n\n  get size() {\n    return this.flattenedRows.length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getItem(key: Key): Node<T> | null {\n    return this.keyMap.get(key) || null;\n  }\n\n  at(idx: number) {\n    return this.flattenedRows[idx];\n  }\n\n  getFirstKey() {\n    return this.flattenedRows[0]?.key;\n  }\n\n  getLastKey() {\n    return this.flattenedRows[this.size - 1]?.key;\n  }\n\n  getKeyAfter(key: Key) {\n    let index = this.flattenedRows.findIndex(row => row.key === key);\n    return this.flattenedRows[index + 1]?.key;\n  }\n\n  getKeyBefore(key: Key) {\n    let index = this.flattenedRows.findIndex(row => row.key === key);\n    return this.flattenedRows[index - 1]?.key;\n  }\n\n  // Note that this will return Content nodes in addition to nested TreeItems\n  getChildren(key: Key): Iterable<Node<T>> {\n    let keyMap = this.keyMap;\n    return {\n      *[Symbol.iterator]() {\n        let parent = keyMap.get(key);\n        let node = parent?.firstChildKey != null ? keyMap.get(parent.firstChildKey) : null;\n        while (node) {\n          yield node as Node<T>;\n          node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;\n        }\n      }\n    };\n  }\n\n  getTextValue(key: Key): string {\n    let item = this.getItem(key);\n    return item ? item.textValue : '';\n  }\n}\n\nexport interface TreeRenderProps {\n  /**\n   * Whether the tree has no items and should display its empty state.\n   * @selector [data-empty]\n   */\n  isEmpty: boolean,\n  /**\n   * Whether the tree is currently focused.\n   * @selector [data-focused]\n   */\n  isFocused: boolean,\n  /**\n   * Whether the tree is currently keyboard focused.\n   * @selector [data-focus-visible]\n   */\n  isFocusVisible: boolean,\n  /**\n   * State of the tree.\n   */\n  state: TreeState<unknown>\n}\n\nexport interface TreeEmptyStateRenderProps extends Omit<TreeRenderProps, 'isEmpty'> {}\n\nexport interface TreeProps<T> extends Omit<AriaTreeGridListProps<T>, 'children'>, CollectionProps<T>, StyleRenderProps<TreeRenderProps>, SlotProps, ScrollableProps<HTMLDivElement>, Expandable {\n  /** How multiple selection should behave in the tree. */\n  selectionBehavior?: SelectionBehavior,\n  /** Provides content to display when there are no items in the list. */\n  renderEmptyState?: (props: TreeEmptyStateRenderProps) => ReactNode,\n  /**\n   * Whether `disabledKeys` applies to all interactions, or only selection.\n   * @default 'selection'\n   */\n  disabledBehavior?: DisabledBehavior\n}\n\n\nexport const UNSTABLE_TreeContext = createContext<ContextValue<TreeProps<any>, HTMLDivElement>>(null);\nexport const UNSTABLE_TreeStateContext = createContext<TreeState<any> | null>(null);\n\nfunction Tree<T extends object>(props: TreeProps<T>, ref: ForwardedRef<HTMLDivElement>) {\n  // Render the portal first so that we have the collection by the time we render the DOM in SSR.\n  [props, ref] = useContextProps(props, ref, UNSTABLE_TreeContext);\n\n  return (\n    <CollectionBuilder content={<Collection {...props} />}>\n      {collection => <TreeInner props={props} collection={collection} treeRef={ref} />}\n    </CollectionBuilder>\n  );\n}\n\ninterface TreeInnerProps<T extends object> {\n  props: TreeProps<T>,\n  collection: ICollection<unknown>,\n  treeRef: RefObject<HTMLDivElement | null>\n}\n\nfunction TreeInner<T extends object>({props, collection, treeRef: ref}: TreeInnerProps<T>) {\n  let {\n    selectionMode = 'none',\n    expandedKeys: propExpandedKeys,\n    defaultExpandedKeys: propDefaultExpandedKeys,\n    onExpandedChange,\n    disabledBehavior = 'selection'\n  } = props;\n  let {CollectionRoot, isVirtualized, layoutDelegate} = useContext(CollectionRendererContext);\n\n  // Kinda annoying that we have to replicate this code here as well as in useTreeState, but don't want to add\n  // flattenCollection stuff to useTreeState. Think about this later\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    propExpandedKeys ? convertExpanded(propExpandedKeys) : undefined,\n    propDefaultExpandedKeys ? convertExpanded(propDefaultExpandedKeys) : new Set(),\n    onExpandedChange\n  );\n\n  let flattenedCollection = useMemo(() => {\n    return new TreeCollection<object>({collection, expandedKeys});\n  }, [collection, expandedKeys]);\n\n  let state = useTreeState({\n    ...props,\n    selectionMode,\n    expandedKeys,\n    onExpandedChange: setExpandedKeys,\n    collection: flattenedCollection,\n    children: undefined,\n    disabledBehavior\n  });\n\n  let {gridProps} = useTreeGridList({\n    ...props,\n    isVirtualized,\n    layoutDelegate\n  }, state, ref);\n\n  let {focusProps, isFocused, isFocusVisible} = useFocusRing();\n  let renderValues = {\n    isEmpty: state.collection.size === 0,\n    isFocused,\n    isFocusVisible,\n    state\n  };\n\n  let renderProps = useRenderProps({\n    className: props.className,\n    style: props.style,\n    defaultClassName: 'react-aria-Tree',\n    values: renderValues\n  });\n\n  let emptyState: ReactNode = null;\n  let emptyStatePropOverrides: HTMLAttributes<HTMLElement> | null = null;\n  if (state.collection.size === 0 && props.renderEmptyState) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    let {isEmpty, ...values} = renderValues;\n    let content = props.renderEmptyState({...values});\n    let treeGridRowProps = {\n      'aria-level': 1,\n      'aria-posinset': 1,\n      'aria-setsize': 1\n    };\n\n    emptyState = (\n      <div role=\"row\" style={{display: 'contents'}} {...treeGridRowProps}>\n        <div role=\"gridcell\" style={{display: 'contents'}}>\n          {content}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <FocusScope>\n      <div\n        {...filterDOMProps(props)}\n        {...renderProps}\n        {...mergeProps(gridProps, focusProps, emptyStatePropOverrides)}\n        ref={ref}\n        slot={props.slot || undefined}\n        onScroll={props.onScroll}\n        data-empty={state.collection.size === 0 || undefined}\n        data-focused={isFocused || undefined}\n        data-focus-visible={isFocusVisible || undefined}>\n        <Provider\n          values={[\n            [UNSTABLE_TreeStateContext, state]\n          ]}>\n          <CollectionRoot\n            collection={state.collection}\n            persistedKeys={usePersistedKeys(state.selectionManager.focusedKey)}\n            scrollRef={ref} />\n        </Provider>\n        {emptyState}\n      </div>\n    </FocusScope>\n  );\n}\n\n/**\n * A tree provides users with a way to navigate nested hierarchical information, with support for keyboard navigation\n * and selection.\n */\nconst _Tree = /*#__PURE__*/ (forwardRef as forwardRefType)(Tree);\nexport {_Tree as UNSTABLE_Tree};\n\n// TODO: readd the rest of the render props when tree supports them\nexport interface TreeItemRenderProps extends Omit<ItemRenderProps, 'allowsDragging' | 'isDragging' | 'isDropTarget'> {\n  /** Whether the tree item is expanded. */\n  isExpanded: boolean,\n  // TODO: api discussion, how do we feel about the below? This is so we can still style the row as grey when a child element within is focused\n  // Maybe should have this for the other collection item render props\n  /** Whether the tree item's children have keyboard focus. */\n  isFocusVisibleWithin: boolean\n}\n\nexport interface TreeItemContentRenderProps extends ItemRenderProps {\n  // Whether the tree item is expanded.\n  isExpanded: boolean,\n  // Whether the tree item has child rows.\n  hasChildRows: boolean,\n  // What level the tree item has within the tree.\n  level: number,\n  // Whether the tree item's children have keyboard focus.\n  isFocusVisibleWithin: boolean\n}\n\n// The TreeItemContent is the one that accepts RenderProps because we would get much more complicated logic in TreeItem otherwise since we'd\n// need to do a bunch of check to figure out what is the Content and what are the actual collection elements (aka child rows) of the TreeItem\nexport interface TreeItemContentProps extends Pick<RenderProps<TreeItemContentRenderProps>, 'children'> {}\n\nexport const UNSTABLE_TreeItemContent = /*#__PURE__*/ createLeafComponent('content', function TreeItemContent(props: TreeItemContentProps) {\n  let values = useContext(TreeItemContentContext)!;\n  let renderProps = useRenderProps({\n    children: props.children,\n    values\n  });\n  return (\n    <CollectionRendererContext.Provider value={DefaultCollectionRenderer}>\n      {renderProps.children}\n    </CollectionRendererContext.Provider>\n  );\n});\n\nexport const TreeItemContentContext = createContext<TreeItemContentRenderProps | null>(null);\n\nexport interface TreeItemProps<T = object> extends StyleRenderProps<TreeItemRenderProps>, LinkDOMProps, HoverEvents {\n  /** The unique id of the tree row. */\n  id?: Key,\n  /** The object value that this tree item represents. When using dynamic collections, this is set automatically. */\n  value?: T,\n  /** A string representation of the tree item's contents, used for features like typeahead. */\n  textValue: string,\n  /** An accessibility label for this tree item. */\n  'aria-label'?: string,\n  /** The content of the tree item along with any nested children. Supports static nested tree items or use of a Collection to dynamically render nested tree items. */\n  children: ReactNode\n}\n\n/**\n * A TreeItem represents an individual item in a Tree.\n */\nexport const UNSTABLE_TreeItem = /*#__PURE__*/ createBranchComponent('item', <T extends object>(props: TreeItemProps<T>, ref: ForwardedRef<HTMLDivElement>, item: Node<T>) => {\n  let state = useContext(UNSTABLE_TreeStateContext)!;\n  ref = useObjectRef<HTMLDivElement>(ref);\n  // TODO: remove this when we support description in tree row\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  let {rowProps, gridCellProps, expandButtonProps, descriptionProps, ...states} = useTreeGridListItem({node: item}, state, ref);\n  let isExpanded = rowProps['aria-expanded'] === true;\n  let hasChildRows = [...state.collection.getChildren!(item.key)]?.length > 1;\n  let level = rowProps['aria-level'] || 1;\n\n  let {hoverProps, isHovered} = useHover({\n    isDisabled: !states.allowsSelection && !states.hasAction,\n    onHoverStart: props.onHoverStart,\n    onHoverChange: props.onHoverChange,\n    onHoverEnd: props.onHoverEnd\n  });\n\n  let {isFocusVisible, focusProps} = useFocusRing();\n  let {\n    isFocusVisible: isFocusVisibleWithin,\n    focusProps: focusWithinProps\n  } = useFocusRing({within: true});\n  let {checkboxProps} = useGridListSelectionCheckbox(\n    {key: item.key},\n    state\n  );\n\n  let renderPropValues = React.useMemo<TreeItemContentRenderProps>(() => ({\n    ...states,\n    isHovered,\n    isFocusVisible,\n    isExpanded,\n    hasChildRows,\n    level,\n    selectionMode: state.selectionManager.selectionMode,\n    selectionBehavior: state.selectionManager.selectionBehavior,\n    isFocusVisibleWithin\n  }), [states, isHovered, isFocusVisible, state.selectionManager, isExpanded, hasChildRows, level, isFocusVisibleWithin]);\n\n  let renderProps = useRenderProps({\n    ...props,\n    id: undefined,\n    children: item.rendered,\n    defaultClassName: 'react-aria-TreeItem',\n    defaultStyle: {\n      // @ts-ignore\n      '--tree-item-level': level\n    },\n    values: renderPropValues\n  });\n\n  useEffect(() => {\n    if (!item.textValue) {\n      console.warn('A `textValue` prop is required for <TreeItem> elements in order to support accessibility features such as type to select.');\n    }\n  }, [item.textValue]);\n\n  let expandButtonRef = useRef<HTMLButtonElement>(null);\n  useEffect(() => {\n    if (hasChildRows && !expandButtonRef.current) {\n      console.warn('Expandable tree items must contain a expand button so screen reader users can expand/collapse the item.');\n    }\n  // eslint-disable-next-line\n  }, []);\n\n  let children = useCachedChildren({\n    items: state.collection.getChildren!(item.key),\n    children: item => {\n      switch (item.type) {\n        case 'content': {\n          return item.render!(item);\n        }\n        // Skip item since we don't render the nested rows as children of the parent row, the flattened collection\n        // will render them each as siblings instead\n        case 'loader':\n        case 'item':\n          return <></>;\n        default:\n          throw new Error('Unsupported element type in TreeRow: ' + item.type);\n      }\n    }\n  });\n\n  return (\n    <>\n      <div\n        {...mergeProps(filterDOMProps(props as any), rowProps, focusProps, hoverProps, focusWithinProps)}\n        {...renderProps}\n        ref={ref}\n        // TODO: missing selectionBehavior, hasAction and allowsSelection data attribute equivalents (available in renderProps). Do we want those?\n        data-expanded={(hasChildRows && isExpanded) || undefined}\n        data-has-child-rows={hasChildRows || undefined}\n        data-level={level}\n        data-selected={states.isSelected || undefined}\n        data-disabled={states.isDisabled || undefined}\n        data-hovered={isHovered || undefined}\n        data-focused={states.isFocused || undefined}\n        data-focus-visible={isFocusVisible || undefined}\n        data-pressed={states.isPressed || undefined}\n        data-selection-mode={state.selectionManager.selectionMode === 'none' ? undefined : state.selectionManager.selectionMode}>\n        <div {...gridCellProps} style={{display: 'contents'}}>\n          <Provider\n            values={[\n              [CheckboxContext, {\n                slots: {\n                  selection: checkboxProps\n                }\n              }],\n              // TODO: support description in the tree row\n              // TODO: don't think I need to pass isExpanded to the button here since it can be sourced from the renderProps? Might be worthwhile passing it down?\n              [ButtonContext, {\n                slots: {\n                  [DEFAULT_SLOT]: {},\n                  chevron: {\n                    ...expandButtonProps,\n                    ref: expandButtonRef\n                  }\n                }\n              }],\n              [TreeItemContentContext, {\n                ...renderPropValues\n              }]\n            ]}>\n            {children}\n          </Provider>\n        </div>\n      </div>\n    </>\n  );\n});\n\nexport interface TreeLoadingIndicatorRenderProps {\n  /**\n   * What level the tree item has within the tree.\n   * @selector [data-level]\n   */\n  level: number\n}\n\nexport interface TreeLoaderProps extends RenderProps<TreeLoadingIndicatorRenderProps>, StyleRenderProps<TreeLoadingIndicatorRenderProps> {}\n\nexport const UNSTABLE_TreeLoadingIndicator = createLeafComponent('loader', function TreeLoader<T extends object>(props: TreeLoaderProps,  ref: ForwardedRef<HTMLDivElement>, item: Node<T>) {\n  let state = useContext(UNSTABLE_TreeStateContext);\n  // This loader row is is non-interactable, but we want the same aria props calculated as a typical row\n  // @ts-ignore\n  let {rowProps} = useTreeGridListItem({node: item}, state, ref);\n  let level = rowProps['aria-level'] || 1;\n\n  let ariaProps = {\n    'aria-level': rowProps['aria-level'],\n    'aria-posinset': rowProps['aria-posinset'],\n    'aria-setsize': rowProps['aria-setsize']\n  };\n\n  let renderProps = useRenderProps({\n    ...props,\n    id: undefined,\n    children: item.rendered,\n    defaultClassName: 'react-aria-TreeLoader',\n    values: {\n      level\n    }\n  });\n\n  return (\n    <>\n      <div\n        role=\"row\"\n        ref={ref}\n        {...mergeProps(filterDOMProps(props as any), ariaProps)}\n        {...renderProps}\n        data-level={level}>\n        <div role=\"gridcell\" aria-colindex={1}>\n          {renderProps.children}\n        </div>\n      </div>\n    </>\n  );\n});\n\nfunction convertExpanded(expanded: 'all' | Iterable<Key>): 'all' | Set<Key> {\n  if (!expanded) {\n    return new Set<Key>();\n  }\n\n  return expanded === 'all'\n    ? 'all'\n    : new Set(expanded);\n}\ninterface TreeGridCollectionOptions {\n  expandedKeys: Set<Key>\n}\n\ninterface FlattenedTree<T> {\n  flattenedRows: Node<T>[],\n  keyMap: Map<Key, CollectionNode<T>>\n}\n\nfunction flattenTree<T>(collection: TreeCollection<T>, opts: TreeGridCollectionOptions): FlattenedTree<T> {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n  let keyMap: Map<Key, CollectionNode<T>> = new Map();\n  let flattenedRows: Node<T>[] = [];\n\n  let visitNode = (node: Node<T>) => {\n    if (node.type === 'item' || node.type === 'loader') {\n      let parentKey = node?.parentKey;\n      let clone = {...node};\n      if (parentKey != null) {\n        // TODO: assumes that non item content node (aka TreeItemContent always placed before Collection) will be always placed before the child rows. If we can't make this assumption then we can filter out\n        // every non-item per level and assign indicies based off the node's position in said filtered array\n        let hasContentNode = [...collection.getChildren(parentKey)][0].type !== 'item';\n        if (hasContentNode) {\n          clone.index = node?.index != null ? node?.index - 1 : 0;\n        }\n\n        // For loader nodes that have a parent (aka non-root level loaders), these need their levels incremented by 1 for parity with their sibiling rows\n        // (Collection only increments the level if it is a \"item\" type node).\n        if (node.type === 'loader') {\n          clone.level = node.level + 1;\n        }\n\n        keyMap.set(clone.key, clone as CollectionNode<T>);\n      } else {\n        keyMap.set(node.key, node as CollectionNode<T>);\n      }\n\n      if (node.level === 0 || (parentKey != null && expandedKeys.has(parentKey) && flattenedRows.find(row => row.key === parentKey))) {\n        // Grab the modified node from the key map so our flattened list and modified key map point to the same nodes\n        flattenedRows.push(keyMap.get(node.key) || node);\n      }\n    } else if (node.type !== null) {\n      keyMap.set(node.key, node as CollectionNode<T>);\n    }\n\n    for (let child of collection.getChildren(node.key)) {\n      visitNode(child);\n    }\n  };\n\n  for (let node of collection) {\n    visitNode(node);\n  }\n\n  return {\n    flattenedRows,\n    keyMap\n  };\n}\n"],"names":[],"version":3,"file":"Tree.module.js.map"}