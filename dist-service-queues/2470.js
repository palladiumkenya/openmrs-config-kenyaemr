"use strict";(globalThis.webpackChunk_openmrs_esm_service_queues_app=globalThis.webpackChunk_openmrs_esm_service_queues_app||[]).push([[2470],{52470:(e,t,n)=>{n.r(t),n.d(t,{default:()=>E,infinite:()=>f,unstable_serialize:()=>c});var r=n(1343),i=n(58139),a=n(55434);const s=r.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;throw"rejected"===e.status?e.reason:(e.status="pending",e.then(t=>{e.status="fulfilled",e.value=t},t=>{e.status="rejected",e.reason=t}),e)}),u={dedupe:!0};a.OBJECT.defineProperty(a.SWRConfig,"defaultValue",{value:a.defaultConfig});const l=(0,a.withArgs)((e,t,n)=>{const{cache:l,compare:d,suspense:c,fallbackData:o,revalidateOnMount:f,revalidateIfStale:E,refreshInterval:g,refreshWhenHidden:p,refreshWhenOffline:_,keepPreviousData:h}=n,[v,U,R,b]=a.SWRGlobalState.get(l),[C,m]=(0,a.serialize)(e),I=(0,r.useRef)(!1),T=(0,r.useRef)(!1),S=(0,r.useRef)(C),V=(0,r.useRef)(t),k=(0,r.useRef)(n),N=()=>k.current,y=()=>N().isVisible()&&N().isOnline(),[L,w,D,F]=(0,a.createCacheHelper)(l,C),O=(0,r.useRef)({}).current,A=(0,a.isUndefined)(o)?n.fallback[C]:o,P=(e,t)=>{for(const n in O){const r=n;if("data"===r){if(!d(e[r],t[r])){if(!(0,a.isUndefined)(e[r]))return!1;if(!d(X,t[r]))return!1}}else if(t[r]!==e[r])return!1}return!0},z=(0,r.useMemo)(()=>{const e=!!C&&!!t&&((0,a.isUndefined)(f)?!N().isPaused()&&!c&&(!!(0,a.isUndefined)(E)||E):f),n=t=>{const n=(0,a.mergeObjects)(t);return delete n._k,e?{isValidating:!0,isLoading:!0,...n}:n},r=L(),i=F(),s=n(r),u=r===i?s:n(i);let l=s;return[()=>{const e=n(L());return P(e,l)?(l.data=e.data,l.isLoading=e.isLoading,l.isValidating=e.isValidating,l.error=e.error,l):(l=e,e)},()=>u]},[l,C]),H=(0,i.useSyncExternalStore)((0,r.useCallback)(e=>D(C,(t,n)=>{P(n,t)||e()}),[l,C]),z[0],z[1]),M=!I.current,W=v[C]&&v[C].length>0,G=H.data,j=(0,a.isUndefined)(G)?A:G,q=H.error,x=(0,r.useRef)(j),X=h?(0,a.isUndefined)(G)?x.current:G:j,Y=!(W&&!(0,a.isUndefined)(q))&&(M&&!(0,a.isUndefined)(f)?f:!N().isPaused()&&(c?!(0,a.isUndefined)(j)&&E:(0,a.isUndefined)(j)||E)),B=!!(C&&t&&M&&Y),J=(0,a.isUndefined)(H.isValidating)?B:H.isValidating,K=(0,a.isUndefined)(H.isLoading)?B:H.isLoading,Q=(0,r.useCallback)(async e=>{const t=V.current;if(!C||!t||T.current||N().isPaused())return!1;let r,i,s=!0;const u=e||{},l=!R[C]||!u.dedupe,c=()=>a.IS_REACT_LEGACY?!T.current&&C===S.current&&I.current:C===S.current,o={isValidating:!1,isLoading:!1},f=()=>{w(o)},E=()=>{const e=R[C];e&&e[1]===i&&delete R[C]},g={isValidating:!0};(0,a.isUndefined)(L().data)&&(g.isLoading=!0);try{if(l&&(w(g),n.loadingTimeout&&(0,a.isUndefined)(L().data)&&setTimeout(()=>{s&&c()&&N().onLoadingSlow(C,n)},n.loadingTimeout),R[C]=[t(m),(0,a.getTimestamp)()]),[r,i]=R[C],r=await r,l&&setTimeout(E,n.dedupingInterval),!R[C]||R[C][1]!==i)return l&&c()&&N().onDiscarded(C),!1;o.error=a.UNDEFINED;const e=U[C];if(!(0,a.isUndefined)(e)&&(i<=e[0]||i<=e[1]||0===e[1]))return f(),l&&c()&&N().onDiscarded(C),!1;const u=L().data;o.data=d(u,r)?u:r,l&&c()&&N().onSuccess(r,C,n)}catch(e){E();const t=N(),{shouldRetryOnError:n}=t;t.isPaused()||(o.error=e,l&&c()&&(t.onError(e,C,t),(!0===n||(0,a.isFunction)(n)&&n(e))&&(N().revalidateOnFocus&&N().revalidateOnReconnect&&!y()||t.onErrorRetry(e,C,t,e=>{const t=v[C];t&&t[0]&&t[0](a.revalidateEvents.ERROR_REVALIDATE_EVENT,e)},{retryCount:(u.retryCount||0)+1,dedupe:!0}))))}return s=!1,f(),!0},[C,l]),Z=(0,r.useCallback)((...e)=>(0,a.internalMutate)(l,S.current,...e),[]);if((0,a.useIsomorphicLayoutEffect)(()=>{V.current=t,k.current=n,(0,a.isUndefined)(G)||(x.current=G)}),(0,a.useIsomorphicLayoutEffect)(()=>{if(!C)return;const e=Q.bind(a.UNDEFINED,u);let t=0;const n=(0,a.subscribeCallback)(C,v,(n,r={})=>{if(n==a.revalidateEvents.FOCUS_EVENT){const n=Date.now();N().revalidateOnFocus&&n>t&&y()&&(t=n+N().focusThrottleInterval,e())}else if(n==a.revalidateEvents.RECONNECT_EVENT)N().revalidateOnReconnect&&y()&&e();else{if(n==a.revalidateEvents.MUTATE_EVENT)return Q();if(n==a.revalidateEvents.ERROR_REVALIDATE_EVENT)return Q(r)}});return T.current=!1,S.current=C,I.current=!0,w({_k:m}),Y&&((0,a.isUndefined)(j)||a.IS_SERVER?e():(0,a.rAF)(e)),()=>{T.current=!0,n()}},[C]),(0,a.useIsomorphicLayoutEffect)(()=>{let e;function t(){const t=(0,a.isFunction)(g)?g(L().data):g;t&&-1!==e&&(e=setTimeout(n,t))}function n(){L().error||!p&&!N().isVisible()||!_&&!N().isOnline()?t():Q(u).then(t)}return t(),()=>{e&&(clearTimeout(e),e=-1)}},[g,p,_,C]),(0,r.useDebugValue)(X),c&&(0,a.isUndefined)(j)&&C){if(!a.IS_REACT_LEGACY&&a.IS_SERVER)throw new Error("Fallback data is required when using suspense in SSR.");V.current=t,k.current=n,T.current=!1;const e=b[C];if(!(0,a.isUndefined)(e)){const t=Z(e);s(t)}if(!(0,a.isUndefined)(q))throw q;{const e=Q(u);(0,a.isUndefined)(X)||(e.status="fulfilled",e.value=!0),s(e)}}return{mutate:Z,get data(){return O.data=!0,X},get error(){return O.error=!0,q},get isValidating(){return O.isValidating=!0,J},get isLoading(){return O.isLoading=!0,K}}}),d=e=>(0,a.serialize)(e?e(0,null):null)[0],c=e=>a.INFINITE_PREFIX+d(e),o=Promise.resolve(),f=e=>(t,n,s)=>{const u=(0,r.useRef)(!1),{cache:l,initialSize:c=1,revalidateAll:f=!1,persistSize:E=!1,revalidateFirstPage:g=!0,revalidateOnMount:p=!1,parallel:_=!1}=s,[,,,h]=a.SWRGlobalState.get(a.cache);let v;try{v=d(t),v&&(v=a.INFINITE_PREFIX+v)}catch(e){}const[U,R,b]=(0,a.createCacheHelper)(l,v),C=(0,r.useCallback)(()=>(0,a.isUndefined)(U()._l)?c:U()._l,[l,v,c]);(0,i.useSyncExternalStore)((0,r.useCallback)(e=>v?b(v,()=>{e()}):()=>{},[l,v]),C,C);const m=(0,r.useCallback)(()=>{const e=U()._l;return(0,a.isUndefined)(e)?c:e},[v,c]),I=(0,r.useRef)(m());(0,a.useIsomorphicLayoutEffect)(()=>{u.current?v&&R({_l:E?I.current:m()}):u.current=!0},[v,l]);const T=p&&!u.current,S=e(v,async e=>{const r=U()._i,i=U()._r;R({_r:a.UNDEFINED});const u=[],d=m(),[c]=(0,a.createCacheHelper)(l,e),o=c().data,E=[];let p=null;for(let e=0;e<d;++e){const[d,c]=(0,a.serialize)(t(e,_?null:p));if(!d)break;const[v,U]=(0,a.createCacheHelper)(l,d);let R=v().data;const b=f||r||(0,a.isUndefined)(R)||g&&!e&&!(0,a.isUndefined)(o)||T||o&&!(0,a.isUndefined)(o[e])&&!s.compare(o[e],R);if(n&&("function"==typeof i?i(R,c):b)){const t=async()=>{if(d in h){const e=h[d];delete h[d],R=await e}else R=await n(c);U({data:R,_k:c}),u[e]=R};_?E.push(t):await t()}else u[e]=R;_||(p=R)}return _&&await Promise.all(E.map(e=>e())),R({_i:a.UNDEFINED}),u},s),V=(0,r.useCallback)(function(e,t){const n="boolean"==typeof t?{revalidate:t}:t||{},r=!1!==n.revalidate;return v?(r&&((0,a.isUndefined)(e)?R({_i:!0,_r:n.revalidate}):R({_i:!1,_r:n.revalidate})),arguments.length?S.mutate(e,{...n,revalidate:r}):S.mutate()):o},[v,l]),k=(0,r.useCallback)(e=>{if(!v)return o;const[,n]=(0,a.createCacheHelper)(l,v);let r;if((0,a.isFunction)(e)?r=e(m()):"number"==typeof e&&(r=e),"number"!=typeof r)return o;n({_l:r}),I.current=r;const i=[],[s]=(0,a.createCacheHelper)(l,v);let u=null;for(let e=0;e<r;++e){const[n]=(0,a.serialize)(t(e,u)),[r]=(0,a.createCacheHelper)(l,n),d=n?r().data:a.UNDEFINED;if((0,a.isUndefined)(d))return V(s().data);i.push(d),u=d}return V(i)},[v,l,V,m]);return{size:m(),setSize:k,mutate:V,get data(){return S.data},get error(){return S.error},get isValidating(){return S.isValidating},get isLoading(){return S.isLoading}}},E=(0,a.withMiddleware)(l,f)}}]);