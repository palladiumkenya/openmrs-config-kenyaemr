"use strict";(globalThis.webpackChunk_openmrs_esm_patient_chart_app=globalThis.webpackChunk_openmrs_esm_patient_chart_app||[]).push([[7495],{9876:(e,t,n)=>{n.r(t),n.d(t,{default:()=>c,immutable:()=>o});var r=n(1343),i=n(8139),a=n(5434);const s=r.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;throw"rejected"===e.status?e.reason:(e.status="pending",e.then((t=>{e.status="fulfilled",e.value=t}),(t=>{e.status="rejected",e.reason=t})),e)}),d={dedupe:!0};a.OBJECT.defineProperty(a.SWRConfig,"defaultValue",{value:a.defaultConfig});const u=(0,a.withArgs)(((e,t,n)=>{const{cache:u,compare:o,suspense:c,fallbackData:l,revalidateOnMount:f,revalidateIfStale:E,refreshInterval:g,refreshWhenHidden:h,refreshWhenOffline:R,keepPreviousData:v}=n,[p,U,_,T]=a.SWRGlobalState.get(u),[V,m]=(0,a.serialize)(e),b=(0,r.useRef)(!1),C=(0,r.useRef)(!1),S=(0,r.useRef)(V),L=(0,r.useRef)(t),O=(0,r.useRef)(n),I=()=>O.current,k=()=>I().isVisible()&&I().isOnline(),[w,D,y,A]=(0,a.createCacheHelper)(u,V),N=(0,r.useRef)({}).current,F=(0,a.isUndefined)(l)?n.fallback[V]:l,P=(e,t)=>{for(const n in N){const r=n;if("data"===r){if(!o(e[r],t[r])){if(!(0,a.isUndefined)(e[r]))return!1;if(!o(z,t[r]))return!1}}else if(t[r]!==e[r])return!1}return!0},M=(0,r.useMemo)((()=>{const e=!!V&&!!t&&((0,a.isUndefined)(f)?!I().isPaused()&&!c&&(!!(0,a.isUndefined)(E)||E):f),n=t=>{const n=(0,a.mergeObjects)(t);return delete n._k,e?{isValidating:!0,isLoading:!0,...n}:n},r=w(),i=A(),s=n(r),d=r===i?s:n(i);let u=s;return[()=>{const e=n(w());return P(e,u)?(u.data=e.data,u.isLoading=e.isLoading,u.isValidating=e.isValidating,u.error=e.error,u):(u=e,e)},()=>d]}),[u,V]),W=(0,i.useSyncExternalStore)((0,r.useCallback)((e=>y(V,((t,n)=>{P(n,t)||e()}))),[u,V]),M[0],M[1]),j=!b.current,G=p[V]&&p[V].length>0,H=W.data,Y=(0,a.isUndefined)(H)?F:H,q=W.error,x=(0,r.useRef)(Y),z=v?(0,a.isUndefined)(H)?x.current:H:Y,B=!(G&&!(0,a.isUndefined)(q))&&(j&&!(0,a.isUndefined)(f)?f:!I().isPaused()&&(c?!(0,a.isUndefined)(Y)&&E:(0,a.isUndefined)(Y)||E)),J=!!(V&&t&&j&&B),K=(0,a.isUndefined)(W.isValidating)?J:W.isValidating,Q=(0,a.isUndefined)(W.isLoading)?J:W.isLoading,X=(0,r.useCallback)((async e=>{const t=L.current;if(!V||!t||C.current||I().isPaused())return!1;let r,i,s=!0;const d=e||{},u=!_[V]||!d.dedupe,c=()=>a.IS_REACT_LEGACY?!C.current&&V===S.current&&b.current:V===S.current,l={isValidating:!1,isLoading:!1},f=()=>{D(l)},E=()=>{const e=_[V];e&&e[1]===i&&delete _[V]},g={isValidating:!0};(0,a.isUndefined)(w().data)&&(g.isLoading=!0);try{if(u&&(D(g),n.loadingTimeout&&(0,a.isUndefined)(w().data)&&setTimeout((()=>{s&&c()&&I().onLoadingSlow(V,n)}),n.loadingTimeout),_[V]=[t(m),(0,a.getTimestamp)()]),[r,i]=_[V],r=await r,u&&setTimeout(E,n.dedupingInterval),!_[V]||_[V][1]!==i)return u&&c()&&I().onDiscarded(V),!1;l.error=a.UNDEFINED;const e=U[V];if(!(0,a.isUndefined)(e)&&(i<=e[0]||i<=e[1]||0===e[1]))return f(),u&&c()&&I().onDiscarded(V),!1;const d=w().data;l.data=o(d,r)?d:r,u&&c()&&I().onSuccess(r,V,n)}catch(e){E();const t=I(),{shouldRetryOnError:n}=t;t.isPaused()||(l.error=e,u&&c()&&(t.onError(e,V,t),(!0===n||(0,a.isFunction)(n)&&n(e))&&(I().revalidateOnFocus&&I().revalidateOnReconnect&&!k()||t.onErrorRetry(e,V,t,(e=>{const t=p[V];t&&t[0]&&t[0](a.revalidateEvents.ERROR_REVALIDATE_EVENT,e)}),{retryCount:(d.retryCount||0)+1,dedupe:!0}))))}return s=!1,f(),!0}),[V,u]),Z=(0,r.useCallback)(((...e)=>(0,a.internalMutate)(u,S.current,...e)),[]);if((0,a.useIsomorphicLayoutEffect)((()=>{L.current=t,O.current=n,(0,a.isUndefined)(H)||(x.current=H)})),(0,a.useIsomorphicLayoutEffect)((()=>{if(!V)return;const e=X.bind(a.UNDEFINED,d);let t=0;const n=(0,a.subscribeCallback)(V,p,((n,r={})=>{if(n==a.revalidateEvents.FOCUS_EVENT){const n=Date.now();I().revalidateOnFocus&&n>t&&k()&&(t=n+I().focusThrottleInterval,e())}else if(n==a.revalidateEvents.RECONNECT_EVENT)I().revalidateOnReconnect&&k()&&e();else{if(n==a.revalidateEvents.MUTATE_EVENT)return X();if(n==a.revalidateEvents.ERROR_REVALIDATE_EVENT)return X(r)}}));return C.current=!1,S.current=V,b.current=!0,D({_k:m}),B&&((0,a.isUndefined)(Y)||a.IS_SERVER?e():(0,a.rAF)(e)),()=>{C.current=!0,n()}}),[V]),(0,a.useIsomorphicLayoutEffect)((()=>{let e;function t(){const t=(0,a.isFunction)(g)?g(w().data):g;t&&-1!==e&&(e=setTimeout(n,t))}function n(){w().error||!h&&!I().isVisible()||!R&&!I().isOnline()?t():X(d).then(t)}return t(),()=>{e&&(clearTimeout(e),e=-1)}}),[g,h,R,V]),(0,r.useDebugValue)(z),c&&(0,a.isUndefined)(Y)&&V){if(!a.IS_REACT_LEGACY&&a.IS_SERVER)throw new Error("Fallback data is required when using suspense in SSR.");L.current=t,O.current=n,C.current=!1;const e=T[V];if(!(0,a.isUndefined)(e)){const t=Z(e);s(t)}if(!(0,a.isUndefined)(q))throw q;{const e=X(d);(0,a.isUndefined)(z)||(e.status="fulfilled",e.value=!0),s(e)}}return{mutate:Z,get data(){return N.data=!0,z},get error(){return N.error=!0,q},get isValidating(){return N.isValidating=!0,K},get isLoading(){return N.isLoading=!0,Q}}})),o=e=>(t,n,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(t,n,r)),c=(0,a.withMiddleware)(u,o)}}]);